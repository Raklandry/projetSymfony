/ *! jQuery v3.3.1 | c) Fondation JS et autres contributeurs | jquery.org/license * /
! function (e, t) {"use strict"; "objet" == typeof module && "objet" == typeof module.exports? module.exports = e.document? t (e,! 0): fonction (e) {if (! e.document) renvoie une nouvelle erreur ("jQuery nécessite une fenêtre avec un document"); renvoie t (e)}: t (e)} ("undefined"! = typeof window? window: this (function) e, t) {"use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n. indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call (Object), h = {}, g = fonction e (t) {return "function "== typeof t &&" numéro "! = typeof t.nodeType}, y = fonction e (t) {retour null! = t && t === t.window}, v = {type:! 0, src:! 0, noModule:! 0}; fonction m (e, t, n) {var i, o = (t = t || r) .createElement ("script"); if (o.text = e, n) pour (i dans v) n [i] && (o [i] = n [i]); t.head.appendChild (o) .parentNode.removeChild (o)} fonction x (e) {retour null == e? e + "": "objet" == typede e || "fonction" == typede e? l [c.call (e)] || " objet ": typede e} var b" "3.3.1", w = fonction (e, t) {retourne un nouveau w.fn.init (e, t)}, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; w.fn = w.prototype = {jquery: "3.3.1", constructeur: w, longueur: 0, toArray: function () {return o.call (this)}, get: function (e) {return null == e? o.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); retourne t.prevObject = ceci, t}, chacun: fonction (e) {retourne w.each (ceci, e)}, map: fonction (e ) {return this.pushStack (w.map (this, fonction (t, n) {return e.call (t, n, t)}))}, slice: function () {retour this.pushStack (o.apply (this, arguments))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (e) {var t = this .longueur, n = + e + (e <0? t: 0);renvoyer this.pushStack (n> = 0 && n <t? [this [n]]: [])}, fin: function () {renvoyer this.prevObject || this.constructor ()}, appuyer sur: s, trier: n .sort, splice: n.splice}, w.extend = w.fn.extend = function () {var, t, n, r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; pour ("booléen" == type de a && (l = a, a = arguments [s] || {}, s ++), "objet" == type de a || g (a) || (a = {}), s === u && (a = ceci, s -); s <u; s ++) if (null! = (e = arguments [s])) pour ( t dans e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r)))? (i? (i =! 1, o = n && Array.isArray (n)? n: []): o = n && w.isPlainObject (n)? n: {}, a [t] = w.extend (l, o, r) ): void 0! == r && (a [t] = r)); retourne a}, w.extend ({expando: "jQuery" + ("3.3.1" + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, erreur: fonction (e) {jeter une nouvelle erreur (e)}, noop: fonction () {},isPlainObject: function (e) {var t, n; return! (! e || "[objet Object]"! == c.call (e)) && (! (t = i (e)) || "fonction "== typeof (n = f.call (t," constructeur ") && t.constructor) && p.call (n) === d)}, isEmptyObject: fonction (e) {var t; pour (t dans e) return! 1; return! 0}, globalEval: fonction (e) {m (e)}, chacun: fonction (e, t) {var n, r = 0; si (C (e)) {pour (n = e.length; r <n; r ++) if (! 1 === t.call (e [r], r, e [r])) break} else pour (r in e) if (! 1 === t.call (e [r], r, e [r])) pause; retour e}, trim: fonction (e) {retour null == e? "" :( e + ""). remplacer (T, " ")}, makeArray: fonction (e, t) {var n = t || []; retourne null! = e && (C (Object (e))? w.merge (n," chaîne "== typede e? [e]: e): s.call (n, e)), n}, inArray: fonction (e, t, n) {retour null == t? -1: u.call (t, e, n) }, merge: function (e, t) {for (var n = + longueur.l, r = 0, i = longueur.l; r <n; r ++) e [i ++] = t [r]; retourne e. longueur = i, e}, grep:fonction (e, t, n) {pour (varr, i = [], o = 0, a = longueur e, s =! n; o <a; o ++) (r =! t (e [o] , o))! == s && i.push (e [o]); renvoyer i}, mapper: fonction (e, t, n) {var r, i, o = 0, s = []; si (C ( e)) pour (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && s.push (i); sinon pour (o dans e) null ! = (i = t (e [o], o, n)) && s.push (i); retourne a.apply ([], s)}, guid: 1, support: h}), "fonction" = = typeof Symbol && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each ("Valeur booléenne Chaîne de fonctions Matrice Date Objet RegExp Symbole d'erreur" .split (""), fonction (e, t) {l ["[objet" + t + "]"] = t.toLowerCase ()}); fonction C (e) {var t = !! e && "longueur" dans e && e.length, n = x (e); return ! g (e) &&! y (e) && ("tableau" === n || 0 === t || "nombre" == typede t && t> 0 && t-1 dans e)} var E = fonction (e ) {var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v,m, x, b = "grésillement" + 1 * nouvelle date, w = e document, T = 0, C = 0, E = ae (), k = ae (), S = ae (), D = fonction (e, t) {retour e === t && (f =! 0), 0}, N = {}. HasOwnProperty, A = [], j = A.pop, q = A.push, L = A. Poussez, H = A. Slice, O = fonction (e, t) {pour (var n = 0, r = longueur e; n <r; n ++) si (e [n] === t) retourne n; return-1}, P = "vérifié | sélectionné | asynchrone | autofocus | lecture automatique | contrôles | différer | désactivé | caché | ismap | boucle | multiple | ouvert | en lecture seule | requis | scoped", M = "[\\ x20 \\ t \\ r \ n \\ f] ", R =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", I =" \\ ["+ M +" * ("+ R +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?: '((:: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + R + ")) |) "+ M +" * \\] ", W =" :( "+ R +") (?: \\ (('((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\ \]] | "+ I +") *) |.*) \\) |) ", $ = nouvelle RegExp (M +" + "," g "), B = nouvelle RegExp (" ^ "+ M +" + ((?: ^ | [^ \\\\]) ) (?: \\\\.) *) "+ M +" + $ "," g "), F = nouveau RegExp (" ^ "+ M +" *, "+ M +" * "), _ = nouveau RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), z = nouveau RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), X = nouvelle RegExp (W), U = nouvelle RegExp (" ^ "+ R +" $ "), V = {ID: nouvelle RegExp (" ^ # ("+ R +") "), CLASS: nouveau RegExp (" ^ \\. ("+ R +") "), TAG: nouveau RegExp (" ^ ("+ R +" | [*]) "), ATTR: nouveau RegExp ("^" + I), PSEUDO: nouveau RegExp ("^" + W), ENFANT: nouveau RegExp ("^ :( seulement | premier | dernier | nième | dernier-dernier) - (enfant | de -type) (?: \\ ("+ M +" * (pair | impair) (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] | ) "+ M +"* (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ P +") $ "," i "), needContext : new RegExp ("^" + M + "* [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, G = / ^ (?: input | select | textarea | button) $ / i, Y = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [natif \ w /, J = / ^ (?: # ([ \ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / [+ ~] /, Z = new RegExp ("\\\\ ([\\ da -f] {1,6} "+ M +"? | ("+ M +") |.) "," ig "), ee = fonction (e, t, n) {varr =" 0x "+ t- 65536; return r! == r || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = fonction (e, t) {retour t? "\ 0" === e? "\ Ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1).toString (16) + "": "\\" + e}, re = fonction () {p ()}, c'est-à-dire = me (fonction (e) {return! 0 === e.disabled && ("form" dans e || "label" dans e)}, {dir: "parentNode", ensuite: "legend"}); essayez {L.apply (A = H.call (w.childNodes), w.childNodes), A [ w.childNodes.length] .nodeType} catch (e) {L = {appliquer: A.length? fonction (e, t) {q.apply (e, H.call (t))}: fonction (e, t ) {var n = longueur e, r = 0; tandis que (e [n ++] = t [r ++]); longueur e = n-1}}} fonction oe (e, t, r, i) {var o , s, l, c, f, h, v, m = t && t.ownerDocument, T = t? t.nodeType: 9; si (r = r || [], "chaîne"! = typede e ||! e || 1! == T && 9! == T && 11! == T) renvoie r; si (! I && ((t? T.ownerDocument || t: w)!! == d && p (t), t = t || d , g)) {if (11! == T && (f = J.exec (e))) if (o = f [1]) {if (9 === T) {if (! (l = t. getElementById (o))) renvoie r; if (l.id === o) renvoie r.push (l), r} sinon si (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) renvoie r.push (l), r} sinon {si (f [2]) renvoie L.apply (r, t.getElementsByTagName (e)), r; si ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) renvoie L.apply (r, t.getElementsByClassName (o)), r} if (n.qsa &&! S [e + ""] && (! Y ||! Y.test ( e)) {{(1! == T) m = t, v = e; sinon si ("objet"! == t.nodeName.toLowerCase ()) {(c = t.getAttribute ("id") )? c = c.replace (te, ne): t.setAttribute ("id", c = b), s = (h = a (e)). length; tandis que (s -) h [s] = "#" + c + "" + ve (h [s]); v = h.join (","), m = K.test (e) && ge (t.parentNode) || t} if (v) try {return L.apply (r, m.querySelectorAll (v)), r} catch (e) {} enfin {c === b && t.removeAttribute ("id")}}} return u (e.replace (B, "$ 1"), t, r, i)} fonction ae () {var e = []; fonction t (n, i) {retour e.push (n + "")>> r.cacheLength && delete t [e.shift ()], t [n + ""] = i} retourne t} fonction se (e) {retourne e [b] =! 0, e} fonction ue (e) {var t = d.createElement ("fieldset" ); essayez {return !! e (t)} catch (e) {return! 1} finally {t.parentNode && t.parentNode.removeChild (t), t = null}} fonction le (e, t) {var n = e.split ("|"), i = longueur.long; tant que (i -) r.attrHandle [n [i]] = t} fonction ce (e, t) {var n = t && e, r = n && 1 = == e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) renvoie r; if (n) tandis que (n = n.nextSibling) si (n === t) renvoie-1; renvoie-1; e? 1: -1} fonction fe (e) {return fonction (t) {return "input" === t.nodeNome.toLowerCase () && t.type === e}} fonction pe (e) {return function (t) {var n = nom.noeud.toLowerCase (); retour ("entrée" === n || "bouton" === n) && t.type === e}} fonction de (e) {retour function (t) {retourne "forme" dans t? t.parentNode &&! 1 === t.disabled? "label" dans t? "label" dans t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled === e: "étiquette" dans t && t.disabled === e}} fonction he (e) {return se (fonction (t) {return t = + t, se (fonction (n, r) {var i, o = e ([], n.longueur, t), a = o.longueur; tandis que (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i])}}}} fonction ge (e) {retour e && "indéfini"! = typeof e.getElementsByTagName && e} n = oe.support = {}, o = oe.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; return! t && "HTML"! == t.nodeName}, p = oe.setDocument = function (e) {var t, i, a = e? e.ownerDocument || e: w; renvoyer a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o ( d), w! == d && (i = d.defaultView) && i.top! == i && (i.addEventListener? i.addEventListener ("unload", re,! 1): i.attachEvent && i.attachEvent ("onunload", re)), n.attributes = ue (fonction (e) {return e.className = "i",! e.getAttribute ("nomClasse")}), n.getElementsByTagName = ue (fonction (e) {retourne e.appendChild (d.createComment ("")),!!! e.getElementsByTagName ("*"). length}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (fonction (e) {retourne h.appendChild (e) .id = b,! D.getElementsByName ||! D.getElementsByName (b) .length}) , n.getById? (r.filter.ID = fonction (e) {var t = remplacement e (Z, ee); fonction return (e) {retour e.getAttribute ("id") === t}} , r.find.ID = function (e, t) {if ("indéfini"! = typede t.getElementById && g) {var n = t.getElementById (e); retourne n? [n]: []}}): (r.filter.ID = fonction (e) {var t = e.remplace (Z, ee); fonction de retour (e) {var n = "non défini"!= typeof e.getAttributeNode && e.getAttributeNode ("id"); retourne n && n.valeur === t}}, r.find.ID = fonction (e, t) {if ("indéfini"! = typede t.getElementById && g) { var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) renvoie [o]; i = t.getElementsByName (e), r = 0; tandis que (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) renvoie [o]} retour [] }}), r.find.TAG = n.getElementsByTagName? fonction (e, t) {return "undefined"! = type of t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++ ]) 1 === n.nodeType && r.push (n); renvoyer r} renvoyer o}, r.find.CLASS = n.getElementsByClassName && fonction (e, t) {if ("indéfini"!! = Typeof. T.getElementsByClassName && g) renvoyer t.getElementsByClassName (e)}, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (fonction (e) {h.appendChild (e) .innerHTML = "<a id='"+b+"'> </a> <select id = '" + b + "- \ r \\' msallowcapture = ''> <option sélectionnée = ''> </ option> </ select> ", e.querySelectorAll (" [[msallowcapture ^ = '']] "). length && y.push (" [* ^ $] = "+ M +" * (?: '' | \ "\") ".) , e.querySelectorAll ("[sélectionné]"). length || y.push ("\\ [" + M + "* (?: valeur |" + P + ")"), e.querySelectorAll ("[id ~ = "+ b +" -] "). length || y.push (" ~ = "), e.querySelectorAll (": vérifié "). length || y.push (": vérifié "), e.querySelectorAll (" a # "+ b +" + * "). length || y.push (". #. + [+ ~]")}), ue (function (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled '> <option /> </ select> "; var t = d.createElement (" entrée "); t.setAttribute (" type "," caché "), e.appendChild (t) .setAttribute (" nom ", "D"), e.querySelectorAll ("[nom = d]"). Length && y.push ("nom" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll ( ": enabled"). length && y.push (": enabled", ": disabled"), h.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": désactivé"). length && y.push (": enabled", ": disabled"), e.querySelectorAll ("* ,: x"), y.push (",. *:")}), (n.matchesSelector = Q.test (m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (fonction (e) {n.disconnectedMatch = m.call (e, "*"), m.call (e, "[s! = '']: x "), v.push ("! = ", W)}), y = y.length && nouvelle RegExp (y.join (" | ")), v = v.length && nouvelle RegExp (v.join (" | ") ), t = Q.test (h.compareDocumentPosition), x = t || Q.test (h.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains? n.contains (r )))}: fonction (e, t) {si (t) tant que (t = t.parentNode) si (t === e) retourne! 0; retourne! 1}, D = t? fonction (e, t ) {if (e === t) retourne f =! 0,0; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; retourne r || (1 & (r = (propriétaire.Document ||)) == = (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! n.sortDetached && t.compareDocumentPosition (e) === r? e === d || e.ownerDocument === w && x (w, e)? - 1: t === d || t.ownerDocument === w && x (w , t)? 1: c? O (c, e) -O (c, t): 0: 4 & r? -1: 1)}: fonction (e, t) {si (e === t) retourne f =! 0,0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (! I ||! O) renvoie e == = d? -1: t === d? 1: i? -1: o? 1: c? O (c, e) -O (c, t): 0; si (i === o) retourne ce (e, t); n = e; tandis que (n = n.parentNode) a.unshift (n); n = t; tandis que (n = n.parentNode) s.unshift (n); tandis que (a [r ] === s [r]) r ++; retourne r? ce (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0}, d): d}, oe.matches = fonction (e, t) {retour ee (e, null, null, t)}, oe.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + ""] && (! v ||! v.test ( t)) && (! y ||! y.test (t))) essayez {var r = appel.c (e, t); if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} return oe (t, d, null, [e]). length> 0}, oe.contains = function (e, t) {return (e.ownerDocument || e)! == d && p (e), x (e, t)}, oe.attr = fonction (e, t) {(e.ownerDocument || e)! == d && p (e); var i = r. attrHandle [t.toLowerCase ()], o = i && N.call (r.attrHandle, t.toLowerCase ())? i (e, t,! g): vide 0; retourne vide 0! == o? o: n .attributes ||! g? e.getAttribute (t) :( o = e.getAttributeNode (t)) &&specified? o.value: null}, oe.escape = fonction (e) {return (e + "") .replace (te, ne)}, oe.error = fonction (e) {lance une nouvelle erreur ("Erreur de syntaxe, expression non reconnue:" + e)}, oe.uniqueSort = fonction (e) {var t, r = [ ], i = 0, o = 0; if (f =! n.detectDuplicates, c =! n.sortStable && e.slice (0), e.sort (D), f) {while (t = e [o ++]) t === e [o] && (i = r.push (o)); tandis que (i -) e.splice (r [i], 1)} renvoie c = null, e}, i = oe. getText = function (e) {var t, n = "", r = 0, o = e.nodeType;if (o) {if (1 === o || 9 === o || 11 === o) {if ("chaîne" == typede e.textContent) retourne e.textContent; pour (e = e .firstChild; e; e = e.nextSibling) n + = i (e)} sinon si (3 === o || 4 === o) retourne e.nodeValue} autre si (t = e [r ++]) n + = i (t); retourne n}, (r = oe.selectors = {cacheLength: 50, createPseudo: se, correspondance: V, attrHandle: {}, recherche: {}, relatif: {">": {dir: "parentNode", d'abord:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}} , preFilter: {ATTR: fonction (e) {retourne e [1] = e [1]. remplace (Z, ee), e [3] = (e [3] || e [4] || e [5 ] || ""). remplacer (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)}, ENFANT: fonction (e) {retourne e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] | | oe.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair"=== e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3] )): e [3] && oe.error (e [0]), e}, PSEUDO: fonction (e) {var t, n =! e [6] && e [2]; renvoyer V.CHILD.test (e [0])? Null: (e [3]? E [2] = e [4] || e [5] || "": n && X.test (n) && (t = a (n,! 0) ) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n. tranche (0, t)), e.slice (0,3))}}, filtre: {TAG: function (e) {var t = e.remplace (Z, ee) .toLowerCase (); retourne "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e) {var t = E [e + " "]; retourne t || (t = nouvelle RegExp (" (^ | "+ M +") "+ e +" ("+ M +" | $) ")) && E (e, fonction (e) {retourne t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")}), ATTR: fonction (e, t, n) {retour fonction (r) {var i = oe.attr (r, e); retour null == i? "! =" === t:! t || (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ = "=== t? n && 0 === i.indexOf (n):" * = "=== t? n && i.indexOf (n)> - 1:" $ = "=== t? n && i.slice ( -n.length) === n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> - 1: "| =" = == t && (i === n || i.slice (0, n.length + 1) === n + "-"))}, ENFANT: fonction (e, t, n, r, i) { var o = "nth"! == e.slice (0,3), a = "dernier"! == e.slice (-4), s = "de type" === t; return 1 == = r && 0 === i? fonction (e) {retour !! e.parentNode}: fonction (t, n, u) {var l, c, f, p, d, h, g = o! == a? "nextSibling": "previousSibling", y = t.parentNode, v = s && t.nodeName.toLowerCase (), m =! u &&! s, x =! 1; si (y) {si (o) {tant que (g) {p = t; tant que (p = p [g]) si (s? p. nodeName.toLowerCase () === v: 1 === p.nodeType) return! 1; h = g = "seulement" === e &&! h && "nextSibling"} return! 0} if (h = [a? y.firstChild: y.lastChild], a && m) {x = (d = (l = (c = (f = (p = y)) [b] || (p [b] = {})) [p.uniqueID ] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) && l [2], p = d && y.childNodes [d]; while ( p = ++ d && p && p [g] || (x = d = 0) || h.pop ()) if (1 === p.nodeType && ++ x && p === t) {c [e] = [T , d, x]; pause}} sinon si (m && (x = d = (l = (c = (f = (p = t) [b] || (p [b] = {}))) [p. uniqueID] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]),! 1 === x) tandis que (p = ++ d && p && p [g] || (x = d = 0) || h.pop ()) if ((s? p.nodeNom.toLowerCase () === v: 1 === p.nodeType) && ++ x && ( m && ((c = (f = p [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] = [T, X]),p === t)) pause; retour (x- = i) === r || x% r == 0 && x / r> = 0}}}, PSEUDO: fonction (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("pseudo non pris en charge:" + e); retourne i [b]? i (t): i.length> 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (fonction (e, n) {varr, o = i (e, t), a = o.longueur; tandis que (a -) e [r = O (e, o [a])] =! (n [r] = o [a])}): fonction (e) {retourne i (e , 0, n)}): i}}, pseudos: {pas: se (fonction (e) {var t = [], n = [], r = s (e.replace (B, "$ 1")) ; return r [b]? se (fonction (e, t, n, i) {varo, a = r (e, nul, i, []), s = e.longueur; tant que (s -) ( o = a [s]) && (e [s] =! (t [s] = o))}): fonction (e, i, o) {retourne t [0] = e, r (t, null, o, n), t [0] = null,! n.pop ()}}), a: se (fonction (e) {retourne fonction (t) {retourne oe (e, t) .longueur> 0}} ), contient: se (fonction (e) {return e = e.remplace (Z, ee), fonction (t) {return (t.textContent || t.innerText || i (t)). indexOf (e) > -1}}), lang:se (fonction (e) {retourne U.test (e || "") || oe.error ("langue non prise en charge:" + e), e = e.remplace (Z, ee) .toLowerCase (), fonction ( t) {var n; do {if (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) = == e || 0 === n.indexOf (e + "-")} tant que ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), cible: fonction (t) {var n = e.location && e.location.hash; return n && n.slice (1) === t.id}, racine: fonction (e) {retour e === h}, focus: fonction (e) {retour e === d.activeElement && (! d.hasFocus || d.hasFocus ()) && !! (type. || e.href || ~ e.tabIndex)}, activé: de (! 1), désactivé : de (! 0), coché: fonction (e) {var t = e.nomNom.toLowerCase (); retourne "entrée" === t && !! e.checked || "option" === t && !! !! .selected}, selected: function (e) {return e.parentNode && e.parentNode.selectedIndex ,!0 === e.selected}, empty: function (e) {pour (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) renvoie! 1; retour! 0}, parent : function (e) {return! r.pseudos.empty (e)}, en-tête: function (e) {return Y.test (e.nodeName)}, entrée: function (e) {return G.test (e. nom_noeud)}, bouton: fonction (e) {var t = nom_noeud.toLowerCase (); retourne "entrée" === t && "bouton" === e.type || "bouton" === t}, text: function (e) {var t; return "input" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, premier: il (fonction () {return [0]}), dernier: he (fonction (e, t) {return [t-1]}) , eq: he (fonction (e, t, n) {return [n <0? n + t: n]}), même: il (fonction (e, t) {pour (var n = 0; n <t ; n + = 2) e.push (n); retour e}), impair: he (fonction (e, t) {pour (var n = 1; n <t; n + = 2) e.push (n); retour e}), lt: il (fonction (e, t,n) {pour (varr = n <0? n + t: n; - r> = 0;) e.push (r); retour e}), gt: he (fonction (e, t, n) {pour (var r = n <0? n + t: n; ++ r <t;) e.push (r); renvoyer e})})). pseudos.nth = r.pseudos.eq; pour ( t dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) r.pseudos [t] = fe (t); pour (t dans {submit:! 0 , reset:! 0}) r.pseudos [t] = pe (t); fonction ye () {} ye.prototype = r.filters = r.pseudos, r.setFilters = nouveau ye, a = oe.tokenize = fonction (e, t) {var n, i, o, a, s, u, l, c = k [e + ""]; si (c) retourne t? 0: c.slice (0); s = e , u = [], l = r.preFilter; tandis que (s) {n &&! (i = F.exec (s)) || (i && (s = slice (i [0] .length) || s ), u.push (o = [])), n =! 1, (i = _. exec (s)) && (n = i.shift (), o.push ({valeur: n, type: i [0] .remplace (B, "")}), s = slice (n.length)); pour (a dans filtre.)! (I = V [a] .exec (s)) || l [a] &&! (i = l [a] (i)) || (n = i.shift (), o.push ({valeur: n, type: a, correspond à: i}), s = s .slice (n.length)); if (! n) break} retourne t? s.length: s? oe.error (e):k (e, u) .slice (0)}; fonction ve (e) {pour (var t = 0, n = longueur e, r = ""; t <n; t ++) r + = e [t]. value; return r} function me (e, t, n) {var r = t.dir, i = t.suivant, o = i || r, a = n && "parentNode" === o, s = C ++; retourne t.first? fonction (t, n, i) {while (t = t [r]) si (1 === t.nodeType || a) retourne e (t, n, i); retourne! 1} : fonction (t, n, u) {var, c, f, p = [T, s]; si (u) {tant que (t = t [r]) if ((1 === t.nodeType | | a) && e (t, n, u)) renvoie! 0} sinon (t = t [r]) if (1 === t.nodeType || a) if (f = t [b] || ( t [b] = {}), c = f [t.uniqueID] || (f [t.uniqueID] = {}), i && i === t.nodeNom.toLowerCase ()) t = t [r] | | t; sinon {si ((l = c [o]) & l [0] === T && l [1] === s) retourne p [2] = l [2]; si (c [o] = p , p [2] = e (t, n, u)) return! 0} return! 1}} function xe (e) {return e.length> 1? function (t, n, r) {var i = e .longueur; tant que (i -) si (! e [i] (t, n, r)) retourne! 1; retourne! 0}: e [0]} fonction soit (e, t, n) {pour ( var r = 0, i = t.longueur; r <i; r ++) oe (e, t [r], n); retourne n} fonction we (e, t, n,r, i) {pour (var o, a = [], s = 0, u = e.longueur, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); retourne une fonction} Te (e, t, n, r, i, o) {retourne r &&! r [b] && (r = Te (r)), i &&! i [b] && (i = Te (i, o)), se (fonction (o, a, s, u) {var l, c, f , p = [], d = [], h = longueur, g = o || be (t || "*", type de noeud? [s]: s, []), y =! e | |! o && t? g: nous (g, p, e, s, u), v = n? i || (o? e: h || r)? []: a: y: si (n && n (y, v, s, u), r) {l = we (v, d), r (l, [], s, u), c = l.longueur; tandis que (c -) (f = l [c] ) && (v [d [c]] =! (y [d [c]] = f))} si (o) {si (i || e) {si (i) {l = [], c = tandis que (c -) (f = v [c]) &&.push (y [c] = f); i (null, v = [], l, u)} c = v.length; tandis que (c -) (f = v [c]) && (l = i? O (o, f): p [c])> - 1 && (o [l] =! (a [l] = f) )}} sinon v = nous (v === a? v.splice (h, v.length): v), i? i (null, a, v, u): L.apply (a, v)} )} fonction Ce (e) {pour (variable, n, i, o = longueur e, longueur = a.relative [e [0]. type], s = a || r.relatif [""], u = a? 1: 0, c = me (fonction (e) {retour e === t}, s,! 0), f = moi (fonction (e) {retour O (t , e)> - 1}, s,! 0), p = [fonction (e, n, r) {var i =! a && (r || n! == l) || ((t = n). nodeType? c (e, n, r): f (e, n, r)); retourne t = null, i}]; u <o; u ++) if (n = r.relatif [e [u] .type ]) p = [me (xe (p), n)]; sinon {if ((n = r.filter [e [u] .type]) .apply (null, e [u] .matches)) [b] ) {pour (i = ++ u; i <o; i ++) if (r.relatif [e [i]. type]) rompt; renvoie Te (u> 1 && xe (p), u> 1 && ve (e.slice ( 0, u-1) .concat ({valeur: "" === e [u-2] .type? "*": ""})). Remplacer (B, "$ 1"), n, u <i && Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e))} p.push (n)} retour xe (p)} fonction Ee (e , t) {var n = t.longueur> 0, i = e.longueur> 0, o = fonction (o, a, s, u, c) {var f, h, y, v = 0, m = " 0 ", x = o && [], b = [], w = l, C = o || i && r.find.TAG (" * ", c), E = T + = null == w? 1: Math.random () || .1, k = LongueurC; pour (c && (l = a === d || a || c); m! == k && null! = (f = C [m]); m ++ ) {if (i && f) {h = 0, a || f.ownerDocument === d || (p (f), s =! g); tandis que (y = e [h ++]) if (y (f, a || d, s)) {u.push (f); pause} c && (T = E)} n && ((f =! y && f) && v -, o && x.push (f))} if (v + = m , n && m! == v) {h = 0; tandis que (y = t [h ++]) y (x, b, a, s); si (o) {si (v> 0) tandis que (m -) x [m] || b [m] || (b [m] = j.call (u)); b = nous (b)} L.apply (u, b), c &&! o && b.length> 0 && v + t .length> 1 && oe.uniqueSort (u)} renvoie c && (T = E, l = w), x}; renvoie n? se (o): o} renvoie s = oe.compile = fonction (e, t) {var n, r = [], i = [], o = S [e + ""]; if (! o) {t || (t = a (e)), n = t.longueur; while (n-- ) (o = Ce (t [n])) [b]? r.push (o): i.push (o); (o = S (e, Ee (i, r))). sélecteur = e} retour o}, u = oe.select = fonction (e, t, n, i) {var o, u, l, c, f, p = "fonction" == typede e && e, d =! i && a (e = p .selector || e);if (n = n || [], 1 === d.length) {if ((u = d [0] = d [0] .slice (0)). length> 2 && "ID" === ( l = u [0]). type && 9 === t.nodeType && g && r.relative [u [1] .type]) {if (! (t = (r.find.ID (l.matches [0] .re , ee), t) || []) [0])) renvoient n; p && (t = t.parentNode), e = e.slice (u.shift (). valeur.longueur)} o = V.needsContext .test (e)? 0: u.longueur; tandis que (o -) {si (l = u [o], r.relative [c = l.type]) break; if ((f = r.find [ c]) && (i = f (l.matches [0] .replace (Z, ee), K.test (u [0] .type) && ge (t.parentNode) || t))) {if (u .splice (o, 1),! (e = longueur de longueur && ve (u))) renvoie L.apply (n, i), n; saut}}} retour (p || s (e, d)) (i , t,! g, n,! t || K.test (e) && ge (t.parentNode) || t), n}, n.sortStable = b.split (""). sort (D) .join. ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (fonction (e) {return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}),ue (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || le (" type | href | height | width ", fonction (e, t, n) {if (! n) retourne e.getAttribute (t," type "=== t.toLowerCase ()? 1: 2)}), n .attributes && ue (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("valeur", ""), "" === e.firstChild.getAttribute ("valeur")} ) || le ("valeur", fonction (e, t, n) {if (! n && "entrée" === e.nodeName.toLowerCase ()) renvoie e.defaultValue}), ue (fonction (e) { return null == e.getAttribute ("disabled")}) || le (P, fonction (e, t, n) {var r; si (! n) retourne! 0 === e [t]? t. toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), oe} (e); w.find = E, w.expr = E.sélecteurs, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = fonction (e, t, n) {var r = [], i = vide 0! == n; tandis que ((e = e [t]) & 9! == e.nodeType) if (1 === e.nodeType ) {if (i && w (e) .is (n)) rupture; r.push (e)} retour r}, S = fonction (e, t) {pour (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); retourne n}, D = w.expr.match.needsContext; fonction N (e, t) {retourne e.nodeName && e.nodeNom.toLowerCase ( ) === t.toLowerCase ()} var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; fonction j (e, t, n) {retour g (t)? w.grep (e, fonction (e, r ) {return !! t.call (e, r, e)! == n}): t.nodeType? w.grep (e, fonction (e) {return e === t! == n}): "chaîne"! = typede t? w.grep (e, fonction (e) {retourne u.call (t, e)> - 1! == n}): w.filter (t, e, n)} w .filter = fonction (e, t, n) {varr = t [0];retourne n && (e = ": not (" + e + "" "), 1 === t.length && 1 === r.nodeType? w.find.matchesSelector (r, e)? [r]: []: w .find.matches (e, w.grep (t, fonction (e) {return 1 === e.nodeType}))}, w.fn.extend ({find: fonction (e) {var t, n, r = this.length, i = this; if ("chaîne"! = typede e) renvoie this.pushStack (w (e) .filter (fonction () {pour (t = 0; t <r; t ++) si ( w.contient (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) w.find (e, i [t ], n); retourne r> 1? w.uniqueSort (n): n}, filtre: fonction (e) {retourne this.pushStack (j (this, e || [!,! 1))}}, pas: function (e) {return this.pushStack (j (this, e || [],! 0))}} est: function (e) {return !! j (this, "string" == typeof e && D.test ( e)? w (e): e || [],! 1) .length}}); var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^> ] * | # ([\ w -] +)) $ /; (w.fn.init = fonction (e, t, n) {var i, o; if (! e) renvoie ceci; if (n = n || q, "chaîne" == typeof e) {if (! (i = "<"=== e [0] &&"> "=== e [e.length-1] && e.length> = 3? [null, e, null]: L.exec (e)) ||! i [ 1] && t) retourne! T || t.jquery? (T || n) .find (e): this.constructor (t) .find (e); if (i [1]) {if (t = t exemple de w? t [0]: t, w.merge (this, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1 ]) && w.isPlainObject (t)) pour (i in t) g (this [i])? this [i] (t [i]): this.attr (i, t [i]); return this} return (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), this} retourne e.nodeType? (this [0] = e, this.length = 1, this): g (e)? void 0! == n.ready? n.ready (e): e (w): w.makeArray (e, this)}). prototype = w.fn, q = w ( r); var H = / ^ (?: parents | prev (?: Jusqu'au | Tous)) /, O = {enfants:! 0, contenu:! 0, suivant:! 0, prev:! 0}; w. fn.extend ({a: fonction (e) {var t = w (e, ceci), n = t.longueur; renvoie this.filter (fonction () {pour (var e = 0; e <n; e ++) if (w.contains (this, t [e])) return! 0})}, le plus proche: function (e,t) {var n, r = 0, i = longueur.a, o = [], a = "chaîne"! = typede e && w (e); if (! D.test (e)) pour (; r <i ; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (n.NodeType <11 && (a? a.index (n)> - 1: 1 === n. nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} renvoie this.pushStack (o.length> 1? w.uniqueSort (o): o)}, index: fonction (e) {return e? "string" == type of e? u.call (w (e), this [0]): u.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? This.first (). PrevAll (). Length: -1}, add: function (e, t) {retour this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))))}, addBack: function (e) {retour this.add (null == e? this.prevObject: this.prevObject.filter (e))}}); fonction P (e, t) {while ((e = e [t]) && 1! == e.nodeType); retourne e} w.each ({parent: fonction (e) {var t = e.nodeparent; retourne t && 11! == t .nodeType? t: null}, parents:fonction (e) {retourne k (e, "parentNode")}, parentsuntil: fonction (e, t, n) {retourne k (e, "parentNode", n)}, suivant: fonction (e) {retourne P ( e, "nextSibling")}, prev: fonction (e) {retour P (e, "previousSibling")}, nextAll: fonction (e) {return k (e, {nextSibling ")}, prevAll: fonction (e) {return k (e, "previousSibling")}, nextUntil: fonction (e, t, n) {return k (e, "nextSibling", n)}, prevUntil: fonction (e, t, n) {return k ( e, "previousSibling", n)}, frères et soeurs: fonction (e) {return S ((e.parentNode || {}). firstChild, e)}, enfants: fonction (e) {return S (e.firstChild) }, contenu: fonction (e) {retourne N (e, "iframe")? e.contentDocument: (N (e, "modèle") && (e = e.content || e), w.merge ([] , e.childNodes))}}, function (e, t) {w.fn [e] = fonction (n, r) {var i = w.map (this, t, n); retourne "jusqu'à"! = = e.slice (-5) && (r = n), r && "chaîne" == typede r && (i = filtre.filtre (r, i)), this.length> 1 && (O [e] || w.uniqueSort (i), H. test (e) && i.reverse ( )), this.pushStack (i)}}); var M = / [^ \ x20 \ t \ r \ n \ f] + / g; fonction R (e) {var t = {}; retourne w.each (e.match (M) || [], fonction (e, n) {t [n] =! 0}), t} w.Callbacks = fonction (e) {e = "chaîne" == typede e? R (e): w.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = fonction () {pour (i = i || e.une, r = t =! 0; a.length; s = -1) {n = a.shift (); tandis que (++ s <o.length)! 1 === o [s] .apply (n [0], n [1]) && e.stopOnFalse && (s = longueur, n =! 1)} ememory || (n =! 1), t =! 1, i && (o = n? []: "")}, l = {add: function () {return o && (n &&! t && (s = o.longueur-1, a.push (n)), fonction t (n) {w. chaque (n, fonction (n, r) {g (r)? e.unique && l.has (r) || o.push (r): r && r.length && "chaîne"! == x (r) && t (r) })} (arguments), n &&! t &&u ()), this}, remove: function () {return w.each (arguments, fonction (e, t) {var n; tant que ((n = w.inArray (t, o, n))>> - 1 ) o.splice (n, 1), n ​​<= s && s -}), this}, a: function (e) {retour e? w.inArray (e, o)> - 1: o.length> 0} , vide: fonction () {retour o && (o = []), ceci}, désactiver: fonction () {retour i = a = [], o = n = "", ceci}, désactivé: fonction () {retour ! o}, lock: function () {return i = a = [], n || t || (o = n = ""), this}, verrouillé: function () {return !! i}, fireWith: fonction (e, n) {retourne i || (n = [e, (n = n || []). slice? n.slice (): n], a.push (n), t || u ( )), this}, fire: function () {return l.fireWith (this, arguments), this}, tiré: function () {return !! r}}; return l}; fonction I (e) {return e } fonction W (e) {lancer e} fonction $ (e, t, n, r) {var i; essayer {e && g (i = e.promise)? i.call (e) .done (t) .fail ( n): e && g (i = e.alors)? i.call (e, t, n): t.apply (vide 0, [e] .slice (r))} catch (e) {n.apply (void 0, [e])}} w.extend ({Différé: fonction (t) {var n = ["notifier", "progression", w.Callbacks ("mémoire"), w.Callbacks ("mémoire"), 2], ["résoudre", " done ", w.Callbacks (" une fois mémoire "), w.Callbacks (" une fois mémoire "), 0," résolu "], [" rejette "," échec ", w.Callbacks (" une fois mémoire "), w .Callbacks ("une fois en mémoire"), 1, "rejeté"]], r = "en attente", i = {état: fonction () {retour r}, toujours: fonction () {retour o.done (arguments). fail (arguments), this}, "catch": function (e) {return i.then (null, e)}, pipe: function () {var e = arguments; retour w.Deferred (function (t) {w .each (n, fonction (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (fonction () {var e = i && i. apply (this, arguments); e && g (e.promise)? e.promise (). progress (t.notify) .done (t.resolve) .fail (t.reject):t [r [0] + "avec"] (ceci, i? [e]: arguments)})}, e = null}). promise ()}, puis: fonction (t, r, i) {var o = 0; fonction a (t, n, r, i) {retour fonction () {var s = ceci, u = arguments, l = fonction () {var e, l; if (! (t <o)) {if ((e = r.apply (s, u)) === n.promise ()) jette un nouveau TypeError ("auto-résolution pouvant être utilisée"); l = e && ("objet" == typeof e || " fonction "== typede e) && e.alors, g (l)? i? l.call (e, a (o, n, I, i), a (o, n, W)) :( o ++, l.call (e, a (o, n, I, i), a (o, n, W, i), a (o, n, I, n.notifyWith))) :( r! == I && ( s = vide 0, u = [e]), (i || n.resolveWith) (s, u))}}, c = i? l: function () {try {l ()} catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = vide 0, u = [e]), n.rejectWith (s, u) )}}; t? c () :( w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} retour w.Deferred (fonction (e) {n [0] [3].ajouter (a (0, e, g (i)? i: I, e.notifyWith)), n [1] [3] .add (a (0, e, g (t)? t: I)), n [2] [3] .add (a (0, e, g (r)? r: W))}). promise ()}, promesse: fonction (e) {retour null! = e? w.extend (e, i): i}}, o = {}; retourne w.each (n, fonction (e, t) {var a = t [2], s = t [5]; i [t [1] ] = a.add, s && a.add (fonction () {r = s}, n [3-e] [2] .disable, n [3-e] [3] .disable, n [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = fonction () {retourne o [t [0] + "avec"] (this === o? void 0: this, arguments), this}, o [t [0] + "With"] = a.fireWith}), i.promise (o), t && t.call (o, o ), o}, quand: fonction (e) {var t = arguments.longueur, n = t, r = tableau (n), i = o.call (arguments), a = w.Deferred (), s = fonction (e) {fonction de retour (n) {r [e] = ceci, i [e] = arguments.length> 1? o.call (arguments): n, - t || a.resolveWith (r, i) }}; if (t <= 1 && ($ (e, a.done (s (n)). résoudre, a.reject,! t), "en attente" === a.state () || g (i [n] && i [n] .then))) return a.then ();while (n -) $ (i [n], s (n), a.reject); retourne a.promise ()}}); var B = / ^ (Eval | Internal | Range | Référence | Syntaxe | Type | URI) Erreur $ /; w.Deferred.exceptionHook = fonction (t, n) {e.console && e.console.warn && t && B.test (t.name) && e.console.warn ("jQuery.Deferred exception:" + t. message, t.stack, n)}, w.readyException = fonction (t) {e.setTimeout (fonction () {lancer t})}; var F = w.Deferred (); w.fn.ready = fonction ( e) {return F.then (e) ["catch"] (fonction (e) {w.readyException (e)}), this}, w.extend ({isReady:! 1, readyWait: 1, ready: fonction (e) {(! 0 === e? - w.readyWait: w.isReady) || (w.isReady =! 0,! 0! = = e && - w.readyWait> 0 || F.resolveWith (r, [w])}}}, w.ready.then = F. puis; function _ () {r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("load", _), w .ready ()} "complete" === r.readyState || "chargement"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener ("DOMContentLoaded", _), e.addEventListener ("load", _)); var z = fonction (e, t, n, r, i, o, a) {var s = 0, u = longueur.l = null == n; si ("objet" === x (n)) {i =! 0; pour ( s dans n) z (e, t, s, n [s],! 0, o, a)} sinon si (void 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (T.call (e, r), t = null) :( l = t, t = fonction (e, t, n) {retourne l.call (w (e), n) })), t)) pour (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n)) ); retourne i? e: l? t.call (e): u? t (e [0], n): o}, X = / ^ - ms - /, U = / - ([az]) / fonction V (e, t) {retour t.toUpperCase ()} fonction G (e) {retour e.replace (X, "ms -"). remplacer (U, V)} var Y = fonction (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; fonction Q () {this.expando = w.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: fonction (e) {var t = e [this.expando]; renvoie t || (t = {}, Y (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {valeur: t, configurable:! 0}))), t}, ensemble: fonction (e, t, n) {var r, i = this.cache (e); if ("chaîne" == type de t) i [G (t)] = n; sinon pour (r dans t) i [G (r)] = t [r] ; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]}, accédez à : fonction (e, t, n) {retourne vide 0 === t || t && "chaîne" == typeof t && vide 0 === n? this.get (e) t:: this.set (e, t , n), vide 0! == n? n: t)}, supprime: fonction (e, t) {var n, r = e [ceci.expando]; if (vide 0! == r) {if ( void 0! == t) {n = (t = Array.isArray (t)? t.map (G) :( t = G (t)) dans r? [t]: t.match (M) || []). length; while (n -) supprimer r [t [n]]} (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: delete e [this.expando])}}, hasData: fonction (e) {var t = e [this.expando]; retourne void 0! == t &&! w.isEmptyObject (t)}}; var J = nouveau Q, K = nouveau Q, Z = / ^ (?:\ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, ee = / [AZ] / g; fonction te (e) {retourne "true" === e || "false"! == e && ("null" === e? null: e === + e + ""? + e: Z.test (e)? JSON.parse (e): e)} fonction ne (e, t, n) {var r; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (ee, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {try {n = te (n)} catch (e) {} K.set (e, t, n)} sinon n = void 0; return n} w.extend ({hasData: function (e) {return K.hasData (e) || J.hasData (e)}, données: function (e, t, n) {return K.access (e, t, n)}, removeData: fonction (e, t) {K.remove (e, t)}, _données: fonction (e, t, n) {renvoie J.access (e, t, n) }, _ removeData: fonction (e, t) {J.remove (e, t)}}), w.fn.extend ({donnée: fonction (e, t) {var n, r, i, o = ceci [ 0], a = o & attribute; if (void 0 === e) {if (this.length && (i = K.get (o), 1 === o.nodeType &&! J.get (o, "hasDataAttrs "))) {n = a.length; tandis que (n -) a [n] && 0 === (r = a [n] .name) .indexOf ("data -") && (r = G (r. slice (5)), ne (o, r, i [r])); J.set (o, "hasDataAttrs",! 0)} retourne i} retourne "objet" == typede e? this.each (fonction () {K.set (this, e)}): z (this, fonction (t) {var n; if (o && void 0 === t) {if (void 0! == (n = K.get ( o, e))) renvoie n; if (void 0! == (n = ne (o, e))) renvoie n} sinon this.each (fonction () {K.set (this, e, t)} )}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {retourne this.each (fonction () {K.remove (this, e)})}}, w.extend ({file: function (e, t, n) {var r; si (e) renvoie t = (t || "fx") + "file", r = J.get (e, t), n && (! r || Array.isArray (n)? r = J.access (e, t, w.makeArray (n)): r.push (n)), r || []}, file d'attente: fonction ( e, t) {t = t || "fx"; var n = w. file d'attente (e, t), r = longueur.i = n.shift (), o = w._queueHooks (e, t) , a = function () {w.dequeue (e, t)}; "inprogress"=== i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), supprimez o.stop, i.call (e, a, o) ),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; retourne J.get (e, n) || J.access (e, n, {vide : w.Callbacks ("une fois en mémoire"). add (function () {J.remove (e, [t + "file d'attente", n])}}}}}), w.fn.extend ({queue: function (e, t) {var n = 2; retourne "chaîne"! = typede e && (t = e, e = "fx", n -), arguments.length <n? w.queue (this [0], e): void 0 === t? this: this.each (function () {var n = w.queue (this, e, t); w._queueHooks (this, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (this, e)}), attendre: function (e) {retourne this.each (function () {w.dequeue (this, e)})}, clearQueue: function (e) {retourne this.queue (e || "fx", [])}, promesse: fonction (e, t) {var n, r = 1, i = w.Différé (), o = ceci, a = ceci.longueur, s = fonction () {- r || i.resolveWith (o, [o])}; "chaîne"! = Typede e && (t = e, e = vide 0), e = e || "fx"; tandis que (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add ( s)); retourne s (), i.promise (t)}}); var re = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -] ? \ d + |) /. source, c'est-à-dire = new RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"), oe = ["Haut", "Droite", "Bas", "Gauche"], ae = fonction (e, t) {retourne "aucun" === (e = t || e) .style.display || " "=== e.style.display && w.contains (e.ownerDocument, e) &&" none "=== w.css (e," display ")}, se = function (e, t, n, r) { var i, o, a = {}; pour (o in t) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r | | []); pour (o dans t) e.style [o] = a [o]; retour i}; fonction ue (e, t, n, r) {var i, o, a = 20,s = r? function () {return r.cur ()}: function () {return w.css (e, t, "")}, u = s (), l = n && n [3] || (w .cssNumber [t]? "": "px"), c = (w.cssNumber [t] || "px"! == l && + u) && ie.exec (w.css (e, t)); if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; tandis que (a -) w.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, style de style (e , t, c + l), n = n || []} renvoie n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [ 2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var le = {}; fonction ce (e) {var t, n = e.ownerDocument, r = e.nodeName, i = le [r]; retourne i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "display") , t.parentNode.removeChild (t), "none" === i && (i = "bloc"), le [r] = i, i)} fonction fe (e, t) {pour (var n, r, i = [], o = 0, a = e.longueur; o <a; o ++) (r = e [o]). style && (n = r.style.display, t? ("none" === n && (i [o] = J.get (r, "display") || null, i [o] || (r.style.display = "")), "" === r.style.display && ae ( r) && (i [o] = ce (r))): "aucune"! == n && (i [o] = "aucune", J.set (r, "display", n))); pour ( o = 0; o <a; o ++) null! = i [o] && (e [o] .style.display = i [o]); retourne e} w.fn.extend ({show: function () { return fe (this,! 0)}, cache: function () {return fe (this)}, bascule: function (e) {return "boolean" == typeof e? e? this.show (): this.hide (): this.each (function () {ae (this)? w (this) .show (): w (this) .hide ()}}); var pe = / ^ (?: case à cocher | radio ) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, il = / ^ $ | ^ module $ | \ / (? : java | ecma) script / i, ge = {option: [1, "<select multiple = 'multiple'>", "</ select>"], thead: [1, "<table>", "</ table> "], col: [2," <table> <colgroup>"," </ colgroup> </ table> "], tr: [2," <table> <tbody> "," </ tbody> </ table> "], td: [3," <table> < tbody> <tr> "," </ tr> </ tbody> </ table> "], _ défaut: [0," "," "]}; ge.optgroup = ge.option, ge.tbody = ge. tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; fonction ye (e, t) {var n; retour n = "indéfini"! = type de e.getElementsByTagName? e.getElementsByTagName ( t || "*"): "undefined"! = type of e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t || t && N (e, t)? w. fusionner ([e], n): n} fonction ve (e, t) {pour (var n = 0, r = longueur.e; n <r; n ++) J.set (e [n], "globalEval" ,! t || J.get (t [n], "globalEval"))} var me = / <| & #? \ w +; /; fonction xe (e, t, n, r, i) {pour ( var o, a, s, u, l, c, f = t.createDocumentFragment (),p = [], d = 0, h = e.longueur; d <h; d ++) if ((o = e [d]) || 0 === o) if ("objet" === x (o )) w.merge (p, o.nodeType? [o]: o); sinon si (me.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + w.htmlPrefilter (o) + u [2], c = u [0]; tandis que (c -) a = a.lastChild; w.merge (p, a.childNodes), (a = f.firstChild) .textContent = " "} else p.push (t.createTextNode (o)); f.textContent =" ", d = 0; tant que (o = p [d ++]) if (r && w.inArray (o, r)> - 1) i && i .push (o); sinon si (l = w.contient (o.ownerDocument, o), a = ye (f.appendChild (o), "script"), l && ve (a), n) {c = 0; while (o = a [c ++]) il.test (o.type || "") && n.push (o)} renvoie f}! function () {var e = r.createDocumentFragment (). appendChild (r.createElement ("div")), t = r.createElement ("entrée"); t.setAttribute ("type", "radio"), t.setAttribute ("coché", "coché"), t.setAttribute ("nom", "t"), e.appendChild (t), h.checkClone = e. cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, e.innerHTML = "<textarea> x </ textarea>", h.noCloneChecked = !! e.cloneNode (! 0) .lastChild.defaultValue} ( ); var soit = ​​r.documentElement, nous = / ^ clé /, Te = / ^ (?: souris | pointeur | menu contextuel | glisser | déposer) | cliquez /, Ce = / ^ ([^.] *) (? : \. (. +) |) /; function Ee () {return! 0} function ke () {return! 1} function Se () {try {return r.activeElement} capture (e) {}} fonction De (e, t, n, r, i, o) {var a, s; if ("objet" == typeof t) {"chaîne"! = typeof n && (r = r || n, n = vide 0) ; pour (s dans t) De (e, s, n, r, t [s], o); retourne e} if (null == r && null == i? (i = n, r = n = vide 0) : null == i && ("chaîne" == typede n? (i = r, r = vide 0) :( i = r, r = n, n = vide 0)),! 1 === i) i = ke;sinon si (! i) retourne e; retourne 1 === o && (a = i, (i = fonction (e) {retourne w (). off (e), a.apply (ceci, arguments)}). guid = a.guid || (a.guid = w.guid ++)), e.each (fonction () {w.event.add (this, t, i, r, n)})} w.event = {global : {}, ajouter: fonction (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, y = J.get (e) ; si (y) {n.handler && (n = (o = n) .handler, i = o.selector), i && w.find.matchesSelector (be, i), n.guid || (n.guid = w. guid ++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) {retourne "indéfini"! = typeof w && w.event.triggered! == t.type? w.event.dispatch.apply (e, arguments): void 0}), l = (t = (t || ""). match (M) || [""]). length; while (l -) d = g = (s = Ce.exec (t [l]) || []) [1], h = (s [2] || "" ) .split ("."). sort (), d && (f = w.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = w .event.special [d] || {}, c = w.extend ({type: d, origType: g, données: r,gestionnaire: n, guid: n.guid, sélecteur: i, needsContext: i && w.expr.match.needsContext.test (i), espace de noms: h.join (".")}, o), (p = u [d ]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (e, r, h, a) || e.addEventListener && e.addEventListener (d, a)), f.add && (f.add.call (e, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p. delegateCount ++, 0, c): p.push (c), w.event.global [d] =! 0)}}, remove: fonction (e, t, n, r, i) {var o, a, s , u, l, c, f, p, d, h, g, y = J.hasData (e) && J.get (e); if (y && (u = y. événements)) {l = (t = ( t || ""). match (M) || [""]). length; tandis que (l -) si (s = Ce.exec (t [l]) || [], d = g = s [1], h = (s [2] || ""). Split ("."). Sort (), d) {f = w.event.special [d] || {}, p = u [ d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. ( ?:. * \\. |) ") +" (\\. | $) "), a = o = p.length;while (o -) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e, c )); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, y.handle) || w.removeEvent (e, d, y.handle), supprimez u [d ])} else pour (d dans u) w.event.remove (e, d + t [l], n, r,! 0); w.isEmptyObject (u) && J.remove (e, "gérer les événements") }}, dispatch: function (e) {var t = w.event.fix (e), n, r, i, o, a, s, u = nouveau Array (arguments.length), l = (J.get (this, "events") || {}) [t.type] || [], c = w.event.special [t.type] || {}; pour (u [0] = t, n = 1; n <arguments.length; n ++) u [n] = arguments [n]; if (t.delegateTarget = this,! C.preDispatch ||! 1! == c.preDispatch.call (this, t)) {s = w.event.handlers.call (this, t, l), n = 0;while ((o = s [n ++]) &&! t.isPropagationStopped ()) {t.currentTarget = o.elem, r = 0; tandis que ((a = o.handlers [r ++]) &&! t.isImmediatePropagationStopped () ) t.rnamespace &&! t.rnamespace.test (a.namespace) || (t.handleObj = a, t.data = a.data, void 0! == (i = ((w.event.special [a. origType] || {}). handle || a.handler) .apply (o.elem, u)) &&! 1 === (t.result = i) && (t.preventDefault (), t.stopPropagation ( )))} retourne c.postDispatch && c.postDispatch.call (this, t), t.result}}, gestionnaires: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("clic" === e.type && e.button> = 1)) pour (; l! == this; l = l.parentNode || this) if (1 === l.nodeType && ("clic"! == e.type ||! 0! == l.disabled)) {pour (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). sélecteur + ""] && (a [i] = r.needsContext? w (i, this) .index (l) >-1: w.find (i, this, null, [l]). Length), un [i] && o.push (r); o.length && s.push ({elem: l, handlers: o})} return l = this, u <t.length && s.push ({elem: l, gestionnaires: t.slice (u)}), s}, addProp: function (e, t) {Object.defineProperty (w.Event.prototype, e, {enumerable:! 0, configurable:! 0, obtenez: g (t)? function () {if (this.originalEvent) renvoie t (this.originalEvent)}: function () {if (this.originalEvent) renvoie this.originalEvent [e]}, set: function (t) {Object.defineProperty (this, e, {enumerable:! 0, configurable:! 0, accessible en écriture:! 0, valeur: t})})},} : function (e) {return e [w.expando]? e: new w.Event (e)}, special: {load: {noBubble:! 0}, focus: {trigger: function () {if (this!! == Se () && this.focus) renvoie this.focus (),! 1}, delegateType: "focusin"}, flou: {trigger: function () {if (this === Se () && this.blur). this.blur (),! 1}, delegateType: "focusout"}, cliquez sur: {trigger:function () {if ("case à cocher" === this.type && this.click && N (this, "input")) renvoie this.click (),! 1}, _ défaut: function (e) {renvoie N (e.target, "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, w.removeEvent = function (e , t, n) {e.removeEventListener && e.removeEventListener (t, n)}, w.Event = fonction (e, t) {if (! (cette instance de w.Event)) renvoie new w.Event (e, t) ; e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ee: ke, this.target = e.target && 3 === e.target.nodeType? e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && w .extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [w.expando] =! 0}, w.Event.prototype = {constructeur: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated :! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e &&! This.isSimulated &&..ventventDefault ()}, stopPropagation: function () {var e = this.isemopeanvente; this.isPropagationStopped = Ee , e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediatePropagrations) .each ({altKey:! 0, bubbles:! 0, annulable:! 0, changeTouches:! 0, ctrlKey:! 0, détail:! 0, eventPhase:! 0, metaKey:! 0, pageX:! 0, pageY :! 0, shiftKey:! 0, view:! 0, "char":! 0, charCode:! 0, clé:! 0, keyCode:! 0, bouton:! 0,boutons:! 0, clientX:! 0, clientY:! 0, offsetX:! 0, offsetY:! 0, pointeurId:! 0, pointeurType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, touche:! 0, qui: function (e) {var t = e.button; renvoie null == e.qui && nous.test (type.e)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Te.test (type.e)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, w.event.addProp), w. each ({mouseenter: "mouseover", mouseleave: "mouseout", pointeurenter: "pointeur arrière", pointerleave: "pointerout"}, fonction (e, t) {w.event.special [e] = {delegateType: t, bindType : t, handle: fonction (e) {var n, r = ceci, i = e.relatedTarget, o = e.handleObj; return i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o.handler.apply (this, arguments), e.type = t), n}}}), w.fn.extend ({on: function (e, t, n, r) {retourne De (ceci, e, t, n, r)}, un: fonction (e, t, n, r) {retourne De (ceci, e, t,n, r, 1)}, off: fonction (e, t, n) {var, i; if (e && e.preventDefault && e.handleObj) renvoie r = e.handleObj, w (e.delegateTarget) .off (r. namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ("object" == typeof e) {pour (i dans e) this.off (i , t, e [i]); return this} return! 1! == t && "fonction"! = typede t || (n = t, t = vide 0),! 1 === n && (n = ke) , this.each (function () {w.event.remove (this, e, n, t)}}}); var Ne = / <(?! zone | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Ae = / <script | <style | <link / i, je = / vérifié \ s * (?: [^ =] | = \ s *. cochée.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [|if ("objet" == typeof e) {pour (i dans e) this.off (i, t, e [i]); retourne ceci} return! 1! == t && "fonction"! = typeof t || (n = t, t = vide 0),! 1 === n && (n = ke), this.each (fonction () {w.event.remove (this, e, n, t) })}}); var Ne = / <(?! zone | br | col | embed | hr | img | entrée | lien | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) / gi, Ae = / <script | <style | <lien / i, je = / vérifié \ s * (?: [^ =] | = \ s * .checked.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [|if ("objet" == typeof e) {pour (i dans e) this.off (i, t, e [i]); retourne ceci} return! 1! == t && "fonction"! = typeof t || (n = t, t = vide 0),! 1 === n && (n = ke), this.each (fonction () {w.event.remove (this, e, n, t) })}}); var Ne = / <(?! zone | br | col | embed | hr | img | entrée | lien | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) / gi, Ae = / <script | <style | <lien / i, je = / vérifié \ s * (?: [^ =] | = \ s * .checked.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [|cochée.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [|cochée.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [|-) | (?: \] \] | -)> \ s * $ / g; fonction Le (e, t) {retourne N (e, "table") && N (11! == t.nodeType? t: t.firstChild, "tr")? w (e) .children ("tbody") [0] || e: e} fonction He (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + type e, e} fonction Oe (e) {retourne "vrai /" === (type e. || ""). slice (0,5)? e. type = e.type.slice (5): e.removeAttribute ("type"), e} fonction Pe (e, t) {var n, r, i, o, a, s, u, l; if (1 === t.nodeType) {if (J.hasData (e) && (o = J.access (e), a = J.set (t, o), l = o.events)) {delete a.handle , a.events = {}; pour (i dans l) pour (n = 0, r = 1 [longueur]; n <r; n ++) w.événement.add (t, i, l [i] [ n])} K.hasData (e) && (s = K.access (e), u = w.extend ({}, s), K.set (t, u))}} fonction Me (e, t ) {var n = nom.noeud.toLowerCase (); "entrée" === n && pe.test (type)? t.checked = e.checked: "entrée"! == n && "textarea"!== n || (t.defaultValue = e.defaultValue)} fonction Re (e, t, n, r) {t = a.apply ([], t); var i, o, s, u, l, c, f = 0, p = longueur e, d = p-1, y = t [0], v = g (y); si (v || p> 1 && "chaîne" == typeof y &&! h. checkClone && je.test (y)) renvoie e.each (fonction (i) {var o = e.eq (i); v && (t [0] = y.call (this, i, o.html ())), Re (o, t, n, r)}); if (p && (i = xe (t, e [0] .ownerDocument,! 1, e, r), o = i.firstChild, 1 === i. childNodes.length && (i = o), o || r)) {pour (u = (s = w.map (ye, "script"), He)). length; f <p; f ++) l = i, f! == d && (l = w.clone (l,! 0,! 0), u && w.merge (s, ye (l, "script"))), n.call (e [f], l , f); si (u) pour (c = s [s.longueur-1]. propriétaireDocument, w.map (s, Oe), f = 0; f <u; f ++) l = s [f], il .test (l.type || "") &&! J.access (l, "globalEval") && w.contains (c, l) && (l.src && "module"! == (l.type || "" ) .toLowerCase ()? w._evalUrl && w._evalUrl (l.src): m (l.textContent.replace (qe, ""), c, l))} renvoie e} fonction Ie (e, t, n) {pour (var r, i = t ? w.filter (t, e): e, o = 0; null! = (r = i [o]); o ++) n || 1! == r.nodeType || w.cleanData (ye (r) ), r.parentNode && (n && w.contains (r.ownerDocument, r) && ve (ye (r, "script")), r.parentNode.removeChild (r)); renvoyer e} w.extend ({htmlPrefilter: function ( e) {return e.replace (Ne, "<$ 1> </ $ 2>")}, clone: ​​fonction (e, t, n) {varr, i, o, a, s = e.cloneNode (! 0 ), u = w.contains (e.ownerDocument, e); if (! (h.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || w.isXMLDoc (e))) pour (a = ye (s), r = 0, i = (o = ye (e)). length; r <i; r ++) Me (o [r], a [r]); si (t) si (n) pour (o = o || ye (e), a = a || ye (s), r = 0, i = longueur.r; r <i; r ++) Pe (o [r], a [r]) ; sinon Pe (e, s); return (a = ye (s, "script")). length> 0 && ve (a,! u && ye (e, "script")), s}, cleanData:fonction (e) {pour (variable, n, r, i = événement spécial, o = 0; vide 0! == (n = e [o]); o ++) si (Y (n)) { if (t = n [J.expando]) {if (t.events) pour (r dans t.events) i [r]? w.event.remove (n, r): w.removeEvent (n, r, t.handle); n [J.expando] = void 0} n [K.expando] && (n [K.expando] = void 0)}}}), w.fn.extend ({detach: function (e ) {return Ie (this, e,! 0)}, supprimez: fonction (e) {return Ie (this, e)}, text: function (e) {return z (this, function (e) {return void 0 === e? w.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, null, e, arguments.length)}, append: function () {return Re (this, arguments, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Le (this, e) .appendChild (e)}), prepend: function () {return Re (this, arguments, function (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Le (this, e);t.insertBefore (e, t.firstChild)}})}, before: function () {return Re (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, après : function () {return Re (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vide: function () {pour (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (ye (e,! 1)), e.textContent = ""); retourne ceci}, clone: ​​fonction (e, t) {retour e = null! = e && e, t = null == t = e: t, this.map (function () {return w.clone (this, e, t)})}, html: function (e) {return z (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t. nodeType) retourne t.innerHTML; if ("chaîne" == typede e &&! Ae.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ( )]) {e = w.htmlPrefilter (e); try {for (; n <r;n ++) 1 === (t = this [n] || {}). nodeType && (w.cleanData (ye (t,! 1)), t.innerHTML = e); t = 0} catch (e) { }} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var e = []; return Re (this, arguments, function (t) {var n = this.parentNode; w.inArray (this, e) <0 && (w.cleanData (ye (this)), n && n.replaceChild (t, this))}, e)}}), w.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, fonction (e, t) {w.fn [e] = fonction (e) {pour ( var n, r = [], i = w (e), o = i.longueur-1, a = 0; a <= o; a ++) n = a === o? ceci: ceci.clone (! 0 ), w (i [a]) [t] (n), s.apply (r, n.get ()); renvoie this.pushStack (r)}}); var We = new RegExp ("^ (" + re + ") (?! px) [az%] + $", "i"), $ e = fonction (t) {var n = t.ownerDocument.defaultView; retourne n && n.opener || (n = e) , n.getComputedStyle (t)}, Be = new RegExp (oe.join ("|"), "i") ;! function () {fonction t () {if (c) {l.style.cssText = "position: absolute ; left: -11111px; width: 60px; margin-top: 1px; padding: 0; border: 0 ", c.style.cssText =" position: relative; display: block; dimensionnement de la boîte: border-box; débordement: scroll: margin: auto; border: 1px; padding: 1px; width: 60%; top: 1% ", be.appendChild (l) .appendChild (c); var t = e.getComputedStyle (c); i =" 1% "! == t.top, u = 12 === n (t.marginLeft), c.style.right =" 60% ", s = 36 === n (t.right), o = 36 === n (t.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild (l), c = null}} fonction n ( e) {return Math.round (parseFloat (e))} var i, o, a, s, u, l = r.createElement ("div"), c = r.createElement ("div"); c.style && (c.style.backgroundClip = "content-box", c.cloneNode (! 0) .style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend (h, {boxSizingReliable: function () {return t (), o}, pixelBoxStyles: function () { renvoyer t (), s}, pixelPosition: function () {renvoyer t (), i}, fiableMarginLeft: function () {renvoyer t (), u}, scrollboxSize: function () {renvoyer t (), a}} ))} (); fonction Fe (e, t, n) {varr, i, o, a, s = e.style; return (n = n || $ e (e)) && (""! = = (a = n.getPropertyValue (t) || n [t]) || w.contains (e.ownerDocument, e) || (a = w.style (e, t)),! h.pixelBoxStyles () && We.test (a) && Be.test (t) && (r = largeur s, i = largeur min, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n. largeur s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} function _e (e, t) {return {get: function () {if (! e ()) renvoie (this.get = t) .apply (this, arguments); supprime this.get}}} var ze = / ^ (none | table (?! - c [ea]). +) /, Xe = / ^ - /,Ue = {position: "absolute", visibilité: "hidden", display: "block"}, Ve = {letterSpacing: "0", fontWeight: "400"}, Ge = ["Webkit", "Moz", " ms "], Ye = r.createElement (" div "). style; fonction Qe (e) {if (e en Ye) renvoie e; var t = e [0] .toUpperCase () + e.slice (1) , n = Longueur ge; tant que (n -) si ((e = Ge [n] + t) dans Ye) renvoie e} fonction Je (e) {var t = w.cssProps [e]; retourne t | | (t = w.cssProps [e] = Qe (e) || e), t} fonction Ke (e, t, n) {var r = ie.exec (t); retourne r? Math.max (0 , r [2] - (n || 0)) + (r [3] || "px"): t} fonction Ze (e, t, n, r, i, o) {var a = "largeur" === t? 1: 0, s = 0, u = 0; si (n === (r? "frontière": "contenu")) renvoie 0; pour (; a <4; a + = 2) " margin "=== n && (u + = w.css (e, n + oe [a],! 0, i)), r? (" contenu "=== n && (u- = w.css (e," Rembourrage "+ oe [a],! 0, i))," marge "! == n && (u- = w.css (e, "bordure" + oe [a] + "largeur",! 0, i))) :( u + = w.css (e, "remplissage" + oe [a],! 0, i), " padding "! == n? u + = w.css (e," bordure "+ oe [a] +" largeur ",! 0, i): s + = w.css (e," bordure "+ oe [a] + "Largeur",! 0, i)); return! R && o> = 0 && (u + = Math.max (0, Math.ceil (e ["offset" "+ +" [t] 0 1)] - ous-.5))), u} fonction et (e, t, n) {varr = $ e (e), i = Fe (e, t, r), o = "cadre-frontière "=== w.css (e," boxSizing ",! 1, r), a = o; if (Nous.test (i)) {if (! n) retourne i; i =" auto "} retourne un = a && (h.boxSizingReliable () || i === e.style [t]), ("auto" === i ||! parseFloat (i) && "inline" === w.css (e, "display",! 1, r)) && (i = e ["offset" + t [0] .to UpperCase () + t.slice (1)], a =! 0), (i = parseFloat (i) || 0) + Ze (e, t, n || (o? "Frontière": "contenu"), a, r, i) + "px"} w.extend ({cssHooks: {opacity: {get: function (e, t) {if (t) {var n = Fe (e, "opacity"); return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacité:! 0, ordre :! 0, orphelins:! 0, veuves:! 0, zIndex:! 0, zoom:! 0}, cssProps: {}, style: fonction (e, t, n, r) {si (e && 3! == e .nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = G (t), u = Xe.test (t), l = e.style; if (u || (t = Je (s)), a = w.cssHooks [t] || w.cssHooks [s], void 0 === n) renvoie a && "get" dans un && void 0! == (i = a.get (e,! 1, r))? I: l [t]; "chaîne" == (o = type de n) && (i = ie.exec (n)) && i [1] && (n = ue (e, t, i ), o = "nombre"), null! = n && n === n && ("nombre" === o && (n + = i && i [3] || (w.cssNumber [s]? "": "px")) , h.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || (l [t] = "inherit"), un && "set" dans un && void 0 === (n = a .set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n))}}, css: fonction (e, t, n, r) {var i , o, a, s = G (t); renvoyer Xe.test (t) || (t = Je (s)), (a = w.cssHooks [t] || w.cssHooks [s]) && " get "dans un && (i = a.get (e,! 0, n)), vide 0 === i && (i = Fe (e, t, r))," normal "=== i && t dans Ve && (i = Ve [t]), "" === n || n? (O = parseFloat (i),! 0 === n || isFinite (o)? O || 0: i): i}}) , w.each (["hauteur", "largeur"], fonction (e, t) {w.cssHooks [t] = {obtenir: fonction (e, n, r) {if (n) renvoie! ze.test (w.css (e, "display")) || e.getClientRects (). length && e.getBoundingClientRect (). width? et (e, t, r): se (e, Ue, fonction () {return et ( e, t, r)})}, set: fonction (e, n, r) {var i, o = $ e (e), a = "border-box" === w.css (e, "boxSizing ",! 1, o), s = r && Ze (e, t, r, a, o); retourne a && h.scrollboxSize () === o.position && (s- = Math.ceil (e [" offset "+ t [0] .toUpperCase () + t.slice (1)] - parseFloat (o [t]) - Ze (e, t, "frontière",! 1, o) -. 5)), s && (i = ie.exec (n)) && "px"! == (i [3] || "px") && (e.style [t] = n, n = w.css (e, t)), Ke ( e, n, s)}}}, w.cssHooks.marginLeft = _e (h.reliableMarginLeft, fonction (e, t) {if (t) return (parseFloat (Fe (e, "marginLeft")) || .getBoundingClientRect (). left-se (e, {marginLeft: 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), w.each ({margin: "", remplissage : "", bordure: "largeur"}, fonction (e, t) {w.cssHooks [e + t] = {développer: fonction (n) {pour (var r = 0, i = {}, o = " chaîne "== type de n? n.split (" "): [n]; r <4; r ++) i [e + oe [r] + t] = o [r] || o [r-2] | | o [0]; retourne i}}, "marge"!== e && (w.cssHooks [e + t] .set = Ke)}), w.fn.extend ({css: fonction (e, t) {retourne z (ceci, fonction (e, t, n) { var r, i, o = {}, a = 0; si (Array.isArray (t)) {pour (r = $ e (e), i = t.longueur; a <i; a ++) o [t [ a]] = w.css (e, t [a],! 1, r); retour o} retour vide 0! == n? w.style (e, t, n): w.css (e, t )}, e, t, arguments.length> 1)}}); fonction tt (e, t, n, r, i) {retourne le nouveau tt.prototype.init (e, t, n, r, i)} w.Tween = tt, tt.prototype = {constructeur: tt, init: fonction (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i | | w.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (w.cssNumber [n]? "" : "px")}, cur: function () {var e = tt.propHooks [this.prop]; renvoyer e && e.get? e.get (this): tt.propHooks._default.get (this)}, exécutez : fonction (e) {var t, n = tt.propHooks [this.prop]; retourne this.options.duration? this.pos = t = w.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration): this.pos = t = e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now) , this), n && n.set? n.set (this): tt.propHooks._default.set (this), this}}, tt.prototype.init.prototype = tt.prototype, tt.propHooks = {_ défaut: { get: function (e) {var t; return 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem.style [e.prop]? e.elem [e.prop] :( t = w.css (e.elem, e.prop, "")) && "auto"! == t? t: 0}, ensemble: fonction (e) {w.fx. étape [e.prop]? w.fx.step [e.prop] (e): 1! == e.elem.nodeType || null == e.elem.style [w.cssProps [e.prop]] &&! w.cssHooks [e.prop]? e.elem [e.prop] = e.now: w.style (e.elem, e.prop, e.now + e.unit)}}}, tt. propHooks.scrollTop = tt.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, w.easing = {linear : fonction (e) {return e}, swing:function (e) {return.5-Math.cos (e * Math.PI) / 2}, _ défaut: "swing"}, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, it = / ^ (?: toggle | show | hide) $ /, ot = / queueHooks $ /; function at () {rt && (! 1 === r.hidden && e.requestAnimationFrame? e.requestAnimationFrame (at ): e.setTimeout (at, w.fx.interval), w.fx.tick ())} function st () {retourne e.setTimeout (function () {nt = vide 0}), nt = Date.now ()} fonction ut (e, t) {var n, r = 0, i = {hauteur: e}; pour (t = t? 1: 0; r <4; r + = 2-t) i ["marge "+ (n = oe [r])] = i [" remplissage "+ n] = e; renvoyer t && (i.opacité = i.width = e), i} fonction lt (e, t, n) {pour (var r, i = (pt.tweeners [t] || []). concat (pt.tweeners ["*"]), o = 0, a = longueur i; o <a; o ++) if (r = i [o] .call (n, t, e)) renvoie r} fonction ct (e, t, n) {var r, i, o, a, s, u, l, c, f = "largeur" dans t || "hauteur" dans t, p = ceci, d = {}, h = style de style, g = type de noeud de noeud && ae (e), y = J.get (e, "fxshow"); n.queue || (null == (a = w._queueHooks (e, "fx")). unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = fonction () {a. unqueued || s ()}), a.unqueued ++, p.always (function () {p.always (function () {a.unqueued -, w.queue (e, "fx"). length || a .empty.fire ()})})); pour (r dans t) if (i = t [r], it.test (i)) {if (supprime t [r], o = o || "bascule "=== i, i === (g?" masquer ":" montrer ")) {if (" montrer "! == i ||! y || void 0 === y [r]) continue; g =! 0} d [r] = y && y [r] || style.w (e, r)} if ((u =! w.isEmptyObject (t)) ||! w.isEmptyObject (d)) {f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get (e, "display")) , "none" === (c = w.css (e, "display")) && (l? c = l: (fe ([e] ,! 0), l = e.style.display || l , c = w.css (e, "display"), fe ([e]))), ("inline" === c || "inline-block "=== c && null! = l) &&" none "=== w.css (e," float ") && (u || (p.done (fonction () {h.display = l}) , null == l && (c = h.display, l = "aucun" === c? "": c)), h.display = "inline-block")), n.overflow && (h.overflow = " hidden ", p.always (function () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), u =! 1; pour (r dans d) u || (y? "Caché" dans y && (g = y.hidden): y = J.access (e, "fxshow", {display: l}), o && (y. hidden =! g), g && fe ([e],! 0), p.done (fonction () {g || fe ([e]), J.remove (e, "fxshow"); pour (r dans d ) w.style (e, r, d [r])}), u = lt (g? y [r]: 0, r, p), r dans y || (y [r] = u.start , g && (u.end = u.start, u.start = 0))}} fonction ft (e, t) {var n, r, i, o, a; pour (n dans e) si (r = G (n), i = t [r], o = e [n], Array.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r &&(e [r] = o, supprimez e [n]), (a = w.cssHooks [r]) && "expand" dans a) {o = a.expand (o), supprimez e [r]; pour ( n dans o) n dans e || (e [n] = o [n], t [n] = i)} sinon t [r] = i} fonction pt (e, t, n) {var r, i , o = 0, a = pt.prefilters.length, s = w.Deferred (). always (function () {delete u.elem}), u = function () {if (i) renvoie! 1; pour ( var t = nt || st (), n = Math.max (0, l.startTime + l.duration-t), r = 1- (n / l.duration || 0), o = 0, a = l.tweens.length; o <a; o ++) l.tweens [o] .run (r); retourne s.notifyWith (e, [l, r, n]), r <1 && a? n: (a || s.notifyWith (e, [l, 1,0]), s.resolveWith (e, [l]),! 1)}, l = s.promise ({elem: e, props: w.extend ({} , t), opte pour: w.extend (! 0, {specialEasing: {}, atténuation: w.easing._default}, n), originalProperties: t, originalOptions: n, heure de début: nt || st (), durée: n.duration, tweens: [], createTween: function (t, n) {var r = w.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing ); retourne l.tweens.push (r), r}, arrêt: function (t) {var n = 0, r = t? l.tweens.length: 0; si (i) renvoie ceci; pour (i =! 0; n <r; n ++) l.tweens [n] .run (1); renvoie t? (s.notifyWith (e, [l , 1,0]), s.resolveWith (e, [l, t])): s.rejectWith (e, [l, t]), this}}, c = l.props; pour (ft (c , l.opts.specialEasing); o <a; o ++) if (r = pt.prefilters [o] .call (l, e, c, l.opts)) renvoie g (r.stop) && (w._queueHooks (l.elem, l.opts.queue) .stop = r.stop.bind (r)), r; retourne w.map (c, lt, l), g (l.opts.start) && l.opts. start.call (e, l), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail). toujours (l.opts. toujours), w.fx.timer (w.extend (u, {elem: e, anim: l, file d'attente: l.opts.queue})), l} w.Animation = w.extend (pt, {tweeners: {"*": [fonction (e, t) {var n = this.createTween (e, t); renvoie ue (n.elem, e, ie.exec (t), n), n}]}, tweener : fonction (e, t) {g (e)? (t = e, e = ["*"]): e = e.match (M); pour (var n, r = 0, i = e.longueur ; r <i; r ++) n = e [r], pt.tweeners [n] = pt.tweeners [n] || [], pt.tweeners [n].unshift (t)}, préfiltres: [ct], préfiltre: fonction (e, t) {t? pt.prefilters.unshift (e): pt.prefilters.push (e)}}), w.speed = fonction ( e, t, n) {var r = e && "objet" == typede e? w.extend ({}, e): {complet: n ||! n && t || g (e) && e, durée: e, accélération : n && t || t &&! g (t) && t}; retourne w.fx.off?r.duration=0:"number"!=typeof r.duration && (r.duration dans w.fx.speeds? r.duration = w.fx.speeds [r.duration]: r.duration = w.fx.speeds._default), null! = r.queue &&! 0! == r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {g (r.old) && r.old.call (this), r.queue && w.dequeue (this, r.queue)}, r}, w. fn.extend ({fadeTo: function (e, t, n, r) {retour this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({opacity: t} , e, n, r)}, animer: fonction (e, t, n, r) {var i = w.isEmptyObject (e), o = w.speed (t, n, r),a = fonction () {var t = pt (this, w.extend ({}, e), o); (i || J.get (this, "finish")) && t.stop (! 0)}; retourne a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, arrêtez: function (e, t, n) {var r = fonction (e) {var t = e.stop; supprime e.stop, t (n)}; renvoie "chaîne"! = typede e && (n = t, t = e, e = vide 0), t &&! 1! == e && this.queue (e || "fx", []), this.each (fonction () {var t =! 0, i = null! = E && e + "queueHooks", o = w.timers, a = J.get (this); if (i) a [i] && a [i] .stop && r (a [i]); sinon pour (i dans a) a [i] && a [i] .stop && ot.test (i ) && r (a [i]); pour (i = longueur. i -;) o [i] .elem! == this || null! = e && o [i] .queue! == e || ( o [i] .anim.stop (n), t =! 1, o.splice (i, 1)) ;! t && n || w.dequeue (this, e)})}, terminer: fonction (e) { return! 1! == e && (e = e || "fx"), this.each (fonction () {var t, n = J.get (this), r = n [e + "queue "], i = n [e +" queueHooks "], o = minuteries, a = r? r.length: 0; pour (n.finish =! 0, w.queue (this, e, []) , i && i.stop && i.stop.call (this,! 0), t = o.length; t -;) o [t] .elem === this && o [t]. Queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); pour (t = 0; t <a; t ++) r [t] && r [t] .finish && r [t] .finish.call (this ); effacer n.fini})}}), w.each (["bascule", "afficher", "masquer"], fonction (e, t) {var n = w.fn [t]; w.fn [t] = fonction (e, r, i) {retour null == e || "boolean" == typeof e? n.apply (this, arguments): this.animate (ut (t,! 0), e , r, i)}}), w.each ({slideDown: ut ("show"), slideUp: ut ("masquer"), slideToggle: ut ("bascule"), fadeIn: {opacity: "show"} , fadeOut: {opacité: "masquer"}, fadeToggle: {opacité: "bascule"}}, fonction (e, t) {w.fn [e] = fonction (e, n, r) {retourne this.animate ( t, e, n, r)}}), w.timers = [], w.fx.tick = function () {var e, t = 0, n = w.timers; pour (nt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e || n.splice (t -, 1); n.length || w.fx.stop (), nt = void 0}, w. fx.timer = function (e) {w.timers.push (e), w.fx.start ()}, w.fx.interval = 13, w.fx.start = fonction () {rt || (rt =! 0, at ())}, w.fx.stop = function () {rt = null}, w.fx.speeds = {lent: 600, rapide: 200, _défaut: 400}, w.fn.delay = fonction (t, n) {retour t = w.fx? w.fx.speeds [t] || t: t, n = n || "fx", this.queue (n, fonction (n, r) {var i = e.setTimeout (n, t); r.stop = fonction () {e.clearTimeout (i)}})}, fonction () {var e = r.createElement ("entrée"), t = r.createElement ("select"). appendChild (r.createElement ("option")); e.type = "case à cocher", h.checkOn = ""! == e.value, h.optSelected = t.selected, (e = r.createElement ("input")). value = "t", e.type = "radio", h.radioValue = "t" === e.valeur} (); var dt, ht = w.expr.attrBasque; w.fn.extend ({attr: fonction (e, t) {retour z (ceci, w.attr, e, t, arguments.length> 1 )}, removeAttr: function (e) {renvoie this.each (function () {w.removeAttr (this, e)})}}), w.extend ({attr: function (e, t, n) {var r, i, o = type de noeud; if (3! == o && 8! == o && 2! == o) retourne "undefined" == type of e.getAttribute? w.prop (e, t, n) :( 1 === o && w.isXMLDoc (e) || (i = w.attrHooks [t.toLowerCase ()] || (w.expr.match.bool.test? dt: void 0)), void 0! == n? null === n? void w.removeAttr (e, t): i && "set" in i && void 0! == (r = i.set (e, n, t))? r: (e. setAttribute (t, n + ""), n): i && "get" dans i && null! == (r = i.get (e, t))? r: null == (r = w.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function (e, t) {if (! h.radioValue && "radio" === t && N (e, "entrée")) {var n = e.valeur; retour e.setAttribute ("type", t), n && (e.value = n), t}}}}, removeAttr: fonction (e, t) {var n, r = 0, i = t && t.match (M); if (i && 1 === e.nodeType) tandis que (n = i [r ++]) e.removeAttribute (n)}}), dt = {set: fonction (e, t, n) {return! 1 === t? w.removeAttr (e, n): e.setAttribute (n, n), n}}, w.each (w.expr.match.bool.source.match (/ \ w + / g), fonction (e, t ) {var n = ht [t] || w.find.attr; ht [t] = fonction (e, t, r) {var i, o, a = t.toLowerCase (); retourne r || (o = ht [a], ht [a] = i, i = null! = n (e, t, r)? a: null, ht [a] = o), i}}); var gt = / ^ ( ?: input | select | textarea | button) $ / i, yt = / ^ (?: a | zone) $ / i; w.fn.extend ({prop: fonction (e, t) {retour z (this, w.prop, e, t, arguments.length> 1)}, removeProp: function (e) {retour this.each (function () {delete this [w.propFix [e] || e}})}}) , w.extend ({prop: fonction (e, t, n) {var r, i, o = type de noeud; si (3! == o && 8! == o && 2! == o) retourne 1 === o && w .isXMLDoc (e) || (t = w.propFix [t] || t, i = w.propHooks [t]), void 0! == n? i && "set" in i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get "in i && null! == (r = i.get (e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = w.find.attr (e , "tabindex"); retourne t? parseInt (t, 10): gt.test (e.nodeName) || yt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {" for ":" htmlFor "," class ":" className "}}, h.optSelected || (w.propHooks.selected = {get: function (e) {var t = e.parentNode; renvoie t && t.parentNode && t. parentNode.selectedIndex, null}, set: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), w.each (["tabIndex", "readOnly" "," maxLength "," cellSpacing "," cellPadding "," rowSpan "," colSpan ","useMap "," frameBorder "," contentEditable "], function () {w.propFix [this.toLowerCase ()] = this}); function vt (e) {return (e.match (M) || []) .join ("")} function mt (e) {return e.getAttribute && e.getAttribute ("class") || ""} function xt (e) {return Array.isArray (e)? e: "string" == typed'e.match (M) || []: []} w.fn.extend ({addClass: fonction (e) {var t, n, r, i, o, a, s, u = 0; if (g (e)) renvoie this.each (fonction (t) {w (this) .addClass (e.call (this, t, mt (this)))}); if ((t = xt (e) ) .length) while (n = this [u ++]) if (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; tandis que (o = t [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = vt (r)) && n.setAttribute ("classe", s)} retourne cela}, removeClass: fonction (e) {var t, n, r, i, o, a, s, u = 0; si (g (e)) retourne this.each (fonction (t) {w (this ).removeClass (e.call (this, t, mt (this)))}); if (! arguments.length) renvoie this.attr ("class", ""); if ((t = xt (e)). longueur) tandis que (n = ce [u ++]) if (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; tandis que (o = t [a ++]) while (r.indexOf ("" + o + "")> - 1) r = r.remplace ("" + o + "", ""); i! == (s = vt (r)) && n.setAttribute ("class", s)} renvoie ceci}, toggleClass: fonction (e, t) {var n = typede e, r = "chaîne" === n || Array.isArray (e); retour " booléen "== typede t && r? t? this.addClass (e): this.removeClass (e): g (e)? this.each (fonction (n) {w (this) .toggleClass (e.call (this, n, mt (ceci), t), t)}): ceci.chaque (fonction () {var t, i, o, a; si (r) {i = 0, o = w (ceci), a = xt (e); while (t = a [i ++]) o.hasClass (t)? o.removeClass (t): o.addClass (t)} sinon vide 0! == e && "booléen"! == n | | ((t = mt (this)) && J.set (this, "__ className __", t), this.setAttribute && this.setAttribute ("class", t ||! 1 === e? "": J.get (this, "__ className __") || "" ))}}}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; tandis que (n = this [r ++]) if (1 === n.nodeType && ( "" + vt (mt (n)) + ") .indexOf (t)> - 1) retourne! 0; retourne! 1}}); var bt = / \ r / g; w.fn.extend ({ val: fonction (e) {var t, n, r, i = ce [0]; {if (arguments.length) renvoie r = g (e), this.each (fonction (n) {var i; 1 = == this.nodeType && (null == (i = r? e.call (this, n, w (this) .val ()): e)? i = "": "nombre" == type de i? i + = "": Array.isArray (i) && (i = w.map (i, fonction (e) {return null == e? "": E + ""})), (t = w.valHooks [this.type ] || w.valHooks [this.nodeName.toLowerCase ()]) && "set" in t && void 0! == t.set (this, i, "valeur ") || (this.value = i))}); if (i) retourne (t = w.valHooks [i.type] || w.valHooks [i.nodeName.toLowerCase ()]) &&" get "in t && void 0! == (n = t.get (i," valeur "))? n:" chaîne "== typeof (n = i.valeur)? n.replace (bt," "): null = = n? "": n}}}), w.extend ({valHooks: {option: {get: function (e)} {var t = w.find.attr (e, "valeur"); return null! = t? t: vt (w.text (e))}}, sélectionnez: {get: fonction (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select- one "=== e.type, s = a? null: [], u = a? o + 1: i.length; pour (r = o <0? u: a oo: 0; r <u; r ++) if ((((n = i [r]). sélectionné || r === o) &&! n.disabled && (! n.parentNode.disabled ||! N (n.parentNode, "optgroup"))) {si (t = w (n) .val (), a) retourne t; s.push (t)} retourne s}, ensemble: fonction (e, t) {varn, r, i = e.options, o = w.makeArray (t), a = longueur.long; tant que (a -) ((r = i [a]). sélectionné = w.inArray (w.valHooks.option.get (r), o) >-1) && (n =! 0); renvoyer n || (e.selectedIndex = -1), o}}}}), w.each (["radio", "case à cocher"], fonction () {w .valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) renvoie e.checked = w.inArray (w (e) .val (), t)> - 1}} , h.checkOn || (w.valHooks [this] .get = fonction (e) {retour null === e.getAttribute ("value")? "sur": e.value})}), h.focusin = "onfocusin" dans e; var wt = / ^ (?: focusinfocus | focusoutblur) $ /, Tt = fonction (e) {e.stopPropagation ()}; w.extend (w.event, {trigger: function (t , n, i, o) {var a, s, u, l, c, p, d, h, v = [i || r], m = f.appel (t, "type")? t.type : t, x = f.call (t, "espace de nom")? t.namespace.split ("."): []; if (s = h = u = i = i || | r, 3! == i .nodeType && 8! == i.nodeType &&! wt.test (m + w.event.triggered) && (m.indexOf (".")> - 1 && (m = (x = m.split (".")). shift (), x.sort ()), c = m.indexOf (":") <0 && "on" + m, t = t [w.expando]? T: new w.Event (m, "object" == typede t && t), t.isTrigger = o? 2: 3, t.namespace = x. join ("."), t.rnamespace = t.namespace? new RegExp ("(^ | \\.)" + x.join ("\\. (?:. * \\. |)") + " (\\. | $) "): null, t.result = void 0, t.target || (t.target = i), n = null == n? [t]: w.makeArray (n, [ t]), d = événement.spécial [m] || {}, o ||! d.trigger ||! 1! == d.trigger.apply (i, n))) {if (! o && ! d.noBubble &&! y (i)) {pour (l = d.DelegateType || m, wt.test (l + m) || (s = s.parentNode); s; s = s. s.parentNode) v. push (s), u = s; u === (i.ownerDocument || r) && v.push (u.defaultView || u.parentWindow || e)} a = 0; while ((s = v [a ++ ]) &&! t.isPropagationStopped ()) h = s, t.type = a> 1? l: d.bindType || m, (p = (J.get (s, "événements") || {}) [t.type] && J.get (s, "handle")) && p.apply (s, n), (p = c && s [c]) && p.apply &&Y (s) && (t.result = p.apply (s, n),! 1 === t.result && t.preventDefault ()); retourne t.type = m, o || t.isDefaultPrevented () || d._default &&! 1! == d._default.apply (v.pop (), n) ||! Y (i) || c && g (i [m]) &&! y (i) && ((u = i [c]) && (i [c] = null), w.event.triggered = m, t.isPropagationStopped () && h.addEventListener (m, Tt), i [m] (), t.isPropagationStopped () && h. removeEventListener (m, Tt), w.event.triggered = void 0, u && (i [c] = u)), t.result}}, simuler: fonction (e, t, n) {var r = w.extend (new w.Event, n, {type: e, isSimulated:! 0}); w.event.trigger (r, null, t)}}), w.fn.extend ({trigger: function (e, t ) {retour this.each (function () {w.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; si (n) retourne w .event.trigger (e, t, n,! 0)}}), h.focusin || w.each ({focus: "focusin", flou: "focusout"}, fonction (e, t) {var n = fonction (e) {w.event.simuler (t, e.target, w.event.fix (e))}; w.event.special [t] = {configuration: function () {var r = ce. document_d'utilisateur || ceci, i = J.access (r, t); i || r.addEventListener (e, n,! 0), J.access (r, t, (i || 0) +1)}, démontage: function () {var r = this .ownDocument || this, i = J.access (r, t) -1; i? J.access (r, t, i) :( r.removeEventListener (e, n,! 0), J.remove (r , t))}}}); var Ct = e.location, Et = Date.now (), kt = / \? /; w.parseXML = fonction (t) {var n; if (! t || " string "! = typeof t) retourne null; essayez {n = (new e.DOMParser) .parseFromString (t," text / xml ")} catch (e) {n = void 0} retourne n &&! n.getElementsByTagName (" parsererror "). length || w.error (" XML invalide: "+ t), n}; var St = / \ [\] $ /, Dt = / \ r? \ n / g, Nt = / ^ ( ?: submit | button | image | reset | file) $ / i, At = / ^ (?: input | select | textarea | keygen) / i; fonction jt (e, t, n, r) {var i; if (Array.isArray (t)) w.each (t, fonction (t, i) {n || St.test (e)? R (e, i): jt (e + "[" + ("object "== typeof i && null! = i? t:" ") +"] ", i, n, r)}); sinon si (n ||" objet "! == x (t)) r (e, t); sinon pour (i dans t) jt (e + "[" + i + "]", t [i], n, r)} w.param = fonction (e, t) {var n, r = [] , i = fonction (e, t) {var n = g (t)? t (): t; r [longueur.ligne] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (Array.isArray (e) || e.jquery &&! w.isPlainObject (e)) w.each (e, fonction () {i (this.name, this.value)}); else for (n dans e) jt (n, e [n], t, i); retourne r.join ("&")}, w.fn.extend ({serialize: function () {return w.param (this. serializeArray ())}, serializeArray: function () {return this.map (function () {var e = w.prop (this, "elements"); retour e? w.makeArray (e): this}). filter (function () {var e = this.type; retourner this.name &&! w (this) .is (": disabled") && At.test (this.nodeName) &&! Nt.test (e) && (this.checked ||! pe.test (e))}). map (fonction (e, t) {var n = w (ceci) .val (); retourne null == n? null : Array.isArray (n)? W.map (n, fonction (e) {return {nom: t.nom, valeur: e.replace (Dt, "\ r \ n")}}): {nom: t .name, valeur: n.replace (Dt, "\ r \ n")}}. get ()}}); var qt = /% 20 / g, Lt = / #. * $ /, Ht = / ([? &]) _ = [^ &] * /, Ot = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm, Pt = / ^ (? : à propos de | app | app-storage |. + - extension | fichier | res | widget): $ /, Mt = / ^ (?: GET | HEAD) $ /, Rt = / ^ \ / \ //, It = {}, Wt = {}, $ t = "* /". Concat ("*"), Bt = r.createElement ("a"); Bt.href = Ct.href; fonction Ft (e) {fonction de retour (t, n) {"chaîne"! = typede t && (n = t, t = "*"); var, i = 0, o = t.toLowerCase (). match (M) || []; if (g (n)) tandis que (r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [r] = e [r ] || []). unshift (n)) :( e [r] = e [r] || []). push (n)}} fonction _t (e, t, n, r) {var i = {}, o = e === Wt;fonction a (s) {var u; retour i [s] =! 0, w.each (e [s] || [], fonction (e, s) {var l = s (t, n, r); retourne "chaîne"! = typede l || o || i [l]? o?! (u = l): vide 0: (t.dataTypes.unshift (l), a (l),! 1)}) , u} retourne a (t.dataTypes [0]) ||! i ["*"] && a ("*")} fonction zt (e, t) {var n, r, i = w.ajaxSettings.flatOptions | | {}; pour (n dans t) vide 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); retour r && w.extend (! 0, e, r), e} fonction Xt (e, t, n) {varr, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type")); if (r) pour (i dans s) si (s [i] && s [i] .test (r)) {u.unhift (i); pause} si (u [0] dans n) o = u [0]; sinon {pour (i dans n) {si (! u [0] || e.convertisseurs [i + "" + u [0]]) {o = i; pause} a || (a = i)} o = o || a} if (o ) retourne o! == u [0] && u.unshift (o), n [o]} fonction Ut (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice (); if (c [1]) pour (a dans les convertisseurs e) l [a.toLowerCase ()] = e.convertisseurs [a]; o = c.shift (); tandis que (o) si (e .responseFields [o] && (n [e.responseFields [o]] = t),! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift () ) if ("*" === o) o = u; sinon if ("*"! == u && u! == o) {if (! (a = l [u + "" + o] || l [" * "+ o])) pour (i dans l) si ((s = i.split (" "))] [1] === o && (a = l [u +" "+ s [0]] || l ["*" + s [0]])) {! 0 === a? a = l [i]:! 0! == l [i] && (o = s [0], c.unshift (s [1]);; break} if (! 0! == a) if (a && e ["jette"]) t = a (t); sinon essayez {t = a (t)} attrapez (e) {return { state: "parsererror", erreur: a? ​​e: "Aucune conversion de" + u + "en" + o}}} return {state: "success", données: t}} w.extend ({active: 0, lastModified : {}, etag: {}, ajaxSettings: {url: Ct.href, tapez: "GET", isLocal: Pt.test (protocole), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", accepte: {"*": $ t, text: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"}, contenu: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, convertisseurs: {"* text ": String," text html ":! 0," text json ": JSON.parse," text xml ": w.parseXML}, flatOptions: {url:! 0, context:! 0}}, ajaxSetup: fonction ( e, t) {retourne t? zt (zt (e, w.ajaxSettings), t): zt (w.ajaxSettings, e)}, ajaxPrefilter: Ft (It), ajaxTransport: Ft (Wt), ajax: fonction ( t, n) {"objet" == typede t && (n = t, t = vide 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup ({}, n), g = h.context || h, y = h.context && (g.nodeType || g.jquery)? w (g): w.event, v = w.Deferred (), m = w.Callbacks ("une fois en mémoire"), x = h.statusCode || {}, b = {}, T = {}, C = "annulé", E = {readyState: 0, getResponseHeader: function (e ) {var t; si (c) {si (! s) {s = {}; tandis que (t = Ot.exec (a)) s [t [1] .toLowerCase ()] = t [2]} t = s [e.toLowerCase ()]} retourne null == t? null: t}, getAllResponseHeaders: function () {retourne c? a: null}, setRequestHeader: fonction (e, t) {retourne null == c && ( e = T [e.toLowerCase ()] = T [e.toLowerCase ()] || e, b [e] = t), this}, overrideMimeType: function (e) {retour null == c && (h.mimeType = e), this}, statusCode: fonction (e) {var t; si (e) si (c) E. toujours (e [E.status]); sinon pour (t dans e) x [t] = [ x [t], e [t]]; renvoie ceci}, annule: fonction (e) {var t = e || C; retourne i && i.abort (t), k (0, t), ceci}}; if (v.promise (E), h.url = ((t || h.url || Ct.href) + ""). remplacer (Rt, Ct.protocol + "//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||""). toLowerCase().match(M ) || [""], null == h.crossDomain) {l = r.createElement ("a"); essayer {l.href = h.url, l.href = l.href, h.crossDomain = Bt .protocol + "//" + Bt.host! = l.protocol + "//" + l.host} catch (e) {h.crossDomain =! 0}} if (h.data && h.processData && "chaîne"! = typeof h.data && (h.data = w.param (h.data, h.traditional)), _ t (It, h, n, E), c) retourne E; (f = w.event && h.global) && 0 == w.active ++ && w.event.trigger ("ajaxStart"), h.type = h.type.toUpperCase (), h.hasContent =! Mt.test (h.type), o = h.url.replace ( Lt, ""), h.hasContent? H.data && h.processData && 0 === (h.contentType || ""). IndexOf ("application / x-www-form-urlencoded") && (h.data = h. data.replace (qt, "+")):(d = h.url.slice (o.length), h.data && (h.processData || "string" == typeof h.data) && (o + = (kt.test (o)? "&": " ? ") + h.data, supprimez h.data),! 1 === h.cache && (o = remplacement.e (Ht," $ 1 "), d = (kt.test (o)?" & ": "?") + "_ =" + Et +++ d), h.url = o + d), h.ifModified && (w.lastModified [o] && E.setRequestHeader ("If-Modified-Since", depuis "Si", depuis. lastModified [o]), w.etag [o] && E.setRequestHeader ("If-None-Match", w.etag [o])), (h.data && h.hasContent &&! 1! == h.contentType || n .contentType) && E.setRequestHeader ("Content-Type", h.contentType), E.setRequestHeader ("Accepter", h.dataTypes [0] && h.accepts [h.dataTypes [0]]? h.accepts [h. dataTypes [0]] + ("*"! == h.dataTypes [0]? "," + $ t + "; q = 0.01": ""): h.accepts ["* "]); pour (p dans les en-têtes) E.setRequestHeader (p, dans les en-têtes [p]); if (h.beforeSend && (! 1 === h.beforeSend.call (g, E, h) || c)) return E.abort (); if (C = "abandon", m.add (h.complete), E.done (h.success), E.fail (h.error), i = _t (Wt, h, n, E)) {if (E.readyState = 1, f && y.trigger ("ajaxSend", [E, h]), c) retourne E; h.async && h.timeout> 0 && (u = e .setTimeout (function () {E.abort ("timeout")}, h.timeout)); essayez {c =! 1, i.send (b, k)} catch (e) {if (c) jette e ; k (-1, e)}} sinon k (-1, "Pas de transport"); fonction k (t, n, r, s) {var, p, d, b, T, C = n; c || (c =! 0, u && e.clearTimeout (u), i = vide 0, a = s || "", E.readyState = t> 0? 4: 0, l = t> = 200 && t <300 || 304 === t, r && (b = Xt (h, E, r)), b = Ut (h, b, E, l), l? (H.ifModified && ((T = E.getResponseHeader ("Last- Modifié ")) && (w.lastModified [o] = T), (T = E.getResponseHeader (" etag ")) && (w.etag [o] = T)), 204 === t || "HEAD" === h.type? C = "nocontent": 304 === t? C = "non modifié": (C = état, p = données, l =! (D = erreur))) :( d = C,! T && C || (C = "erreur", t <0 && (t = 0) )), E.status = t, E.statusText = (n || C) + "", l? V.resolveWith (g, [p, C, E]): v.rejectWith (g, [E, C , d]), E.statusCode (x), x = vide 0, f && y.trigger (l? "ajaxSuccess": "ajaxError", [E, h, l? p: d]), m.fireWith (g, [E, C]), f && (y.trigger ("ajaxComplete", [E, h]), - w.active || w.event.trigger ("ajaxStop"))} retour E}, getJSON: fonction (e, t, n) {retour w.get (e, t, n, "json")}, getScript: fonction (e, t) {retour w.get (e, void 0, t, "script" )}}), w.each (["get", "post"], fonction (e, t) {w [t] = fonction (e, n, r, i) {retourne g (n) && (i = i || r, r = n, n = vide 0), w.ajax (w.extend ({url: e, type: t, type de données: i,data: n, success: r}, w.isPlainObject (e) && e))}}), w._evalUrl = fonction (e) {return w.ajax ({url: e, type: "GET", dataType: " script ", cache:! 0, async:! 1, global:! 1," jette ":! 0})}, w.fn.extend ({wrapAll: function (e) {var t; retourne ce [0] && (g (e) && (e = e.call (this [0])), t = w (e, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; renvoyer e}). append (this)), this}, wrapInner: function (e) {return g (e)? this.each (function (t) {w (this) .wrapInner (e.call (this, t))}): this.each (function () {var t = w (this), n = t.contents (); n.length? n.wrapAll (e): t.append (e)}), wrap: function (e) {var t = g (e) ; return this.each (function (n) {w (this) .wrapAll (t? e.call (this, n): e)})}, unwrap: function (e) {return this.parent (e). pas le corps").each (function () {w (this) .replaceWith (this.childNodes)}), this}}), w.expr.pseudos.hidden = fonction (e) {return! w.expr.pseudos.visible (e) }, w.expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, w.ajaxSettings.xhr = function () {try {retour new e.XMLHttpRequest} catch (e) {}}; var Vt = {0: 200,1223: 204}, Gt = w.ajaxSettings.xhr (); h.cors = !! Gt && "withCredentials" dans Gt , h.ajax = Gt = !! Gt, w.ajaxTransport (fonction (t) {var n, r; si (h.cors || Gt &&! t.crossDomain) retourne {send: function (i, o) {var a, s = t.xhr (); if (s.open (type.tur, t.url, t.async, t.nomutilisateur, t.password), t.xhrFields) pour (a dans t.xhrFields) s [a] = t.xhrFields [t]; t.mimeType && s.overrideMimeType && s.overrideMimeType (t.mimeType), t.crossDomain || i ["Requête-avec-X"] || (i ["Requête-avec-X "] =" XMLHttpRequest "); pour (a dans i) s.setRequestHeader (a, i [a]); n = fonction (e) {retour fonction () {n && (n = r = chargement = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "Abort" === e? s.abort (): "erreur" === e? "numéro"! = typede statut.o (0, "erreur"): o (s.status, s.statusText ): o (Vt [s.status] || s.status, s.statusText, "text"! == (s.responseType || "text") || "string"! = type de s.responseText? {binaire : s.response}: {text: s.responseText}, s.getAllResponseHeaders ()))}}, s.onload = n (), r = s.onerror = s.ontimeout = n ("erreur"), void 0! == s.onabort? S.onabort = r: s.onreadystatechange = function () {4 === s.readyState && e.setTimeout (function () {n && r ()})}, n = n ("annulation" ); try {s.send (t.hasContent && t.data || null)} catch (e) {if (n) renvoie e}}, abort: function () {n && n ()}}}), w.ajaxPrefilter ( fonction (e) {e.crossDomain && (e.contents.script =! 1)}), w.ajaxSetup ({accepte: {script: "texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenu: {script: / \ b ( ?: java | ecma) script \ b /}, convertisseurs: {"script de texte": fonction (e) {retour w.globalEval (e), e}}}), w.ajaxPrefilter ("script", fonction (e ) {void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), w.ajaxTransport ("script", fonction (e) {if (e .crossDomain) {var t, n; retour {send: function (i, o) {t = w ("<script>"). prop ({charset: e.scriptCharset, src: e.url}). on ( "erreur de chargement", n = fonction (e) {t.remove (), n = null, e && o ("erreur" === e.type? 404: 200, e.type)}), r.head.appendChild (t [0])}, annule: function () {n && n ()}}}}); var Yt = [], Qt = / (=) \? (? = & | $) | \? \? / ; w.ajaxSetup ({jsonp: "callback", jsonpCallback:function () {var e = Yt.pop () || w.expando + "_" + Et ++; renvoie ceci [e] =! 0, e}}), w.ajaxPrefilter ("json jsonp", fonction (t, n, r) {var i, o, a, s =! 1! == t.jsonp && (Qt.test (t.url)? "url": "chaîne" == typede t.data && 0 === (t .contentType || ""). indexOf ("application / x-www-form-urlencoded") && Qt.test (t.data) && "data"); if (s || "jsonp" === t.dataTypes [0]) renvoie i = t.jsonpCallback = g (t.jsonpCallback)? T.jsonpCallback (): t.jsonpCallback, s? T [s] = t [s] .remplace (Qt, "$ 1" + i) :! 1! == t.jsonp && (t.url + = (kt.test (t.url)? "&": "?") + T.jsonp + "=" + i), t.convertisseurs ["script json "] = function () {return a || w.error (i +" n'a pas été appelé "), a [0]}, t.dataTypes [0] =" json ", o = e [i], e [i ] = function () {a = arguments}, r.a toujours (function () {void 0 === o? w (e).removeProp (i): e [i] = o, t [i] && (t.jsonpCallback = n.jsonpCallback, Yt.push (i)), a && g (o) && o (a [0]), a = o = void 0}), "script"}), h.createHTMLDocument = function () {var e = im.implementation.createHTMLDocument (""). body; return e.innerHTML = "<formulaire> </ formulaire> <formulaire> </ form> ", 2 === e.childNodes.length} (), w.parseHTML = fonction (e, t, n) {if (" chaîne "! = typede e) retour [];" booléen "= = typede t && (n = t, t =! 1); var i, o, a; retourne t || (h.createHTMLDocument? ((i = (t = r.implementation.createHTMLDocument ("")). "base")). href = r.location.href, t.head.appendChild (i)): t = r), o = A.exec (e), a =! n && [], o? [t. createElement (o [1])] :( o = xe ([e], t, a), a && a.length && w (a) .remove (), w.merge ([], o.childNodes))}, w. fn.load = fonction (e, t, n) {varr, i, o, a = ceci, s = e.indexOf ("");retourne s> -1 && (r = vt (e.slice (s)), e = e.slice (0, s)), g (t)? (n = t, t = vide 0): t && "objet" == typede t && (i = "POST"), a.length> 0 && w.ajax ({url: e, type: i || "GET", type de données: "html", données: t}). done (fonction ( e) {o = arguments, a.html (r? w ("<div>"). append (w.parseHTML (e)). find (r): e)}). toujours (n && fonction (e, t) {a.each (function () {n.apply (this, o || [e.responseText, t, e])})}), this}, w.each (["ajaxStart", "ajaxStop", " ajaxComplete "," ajaxError "," ajaxSuccess "," ajaxSend "], fonction (e, t) {w.fn [t] = fonction (e) {renvoie this.on (t, e)}}), w. expr.pseudos.animated = function (e) {return w.grep (w.timers, function (t) {return e === t.elem}). length}, w.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l, c = w.css (e, "position"), f = w (e), p = {}; "statique"=== c && (style.position = "relatif"), s = f.offset (), o = w.css (e, "haut"), u = w.css (e, "gauche"), (l = ("absolu" === c || "fixé" === c) && (o + u) .indexOf ("auto")> - 1)? (a = (r = f.position () ) .top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), g (t) && (t = t.call (e, n, w .extend ({}, s))), null! = t.top && (p.top = t.top-s.top + a), null! = t.left && (p.left = t.left-s. left + i), "utiliser" dans t? t.using.call (e, p): f.css (p)}}, w.fn.extend ({offset: function (e) {if (arguments.length ) retourne vide 0 === e? ceci: ceci.chaque (fonction (t) {w.offset.setOffset (ceci, e, t)}); var t, n, r = ceci [0]; if (r ) retourne r.getClientRects (). length? (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {haut: t.top + n.pageYOffset, gauche: t.left + n.pageXOffset}): {top: 0, left: 0}}, position: function () {if (this [0]) {var e, t, n, r = this [0], i = {top: 0,left: 0}; if ("fixed" === w.css (r, "position")) t = r.getBoundingClientRect (); else {t = this.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "statique" === w.css (e, "position")) e = e.parentNode; e && e! == r && 1 === e.nodeType && ((i = w (e) .offset ()). haut + = w.css (e, "borderTopWidth",! 0), i.left + = w .css (e, "borderLeftWidth",! 0))} return {top: t.top-i.top-w.css (r, "marginTop",! 0), à gauche: t.left-i.left- w.css (r, "marginLeft",! 0)}}}, offsetParent: function () {return this.map (function () {var e = this.offsetParent; while (e && "static" === w. css (e, "position")) e = e.offsetParent; retourne e || be})}}), w.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (e, t) {var n = "pageYOffset "=== t; w.fn [e] = fonction (r) {retour z (cette fonction (e, r, i) {var o; si (y (e)? o = e: 9 == = e.nodeType && (o = e.defaultView), vide 0 === i) renvoyer o? o [t]: e [r]; o? o.scrollTo (n? o.pageXOffset: i, n? i: o.pageYOffset): e [r] = i}, e, r, arguments.length)}}), w.each (["haut", "gauche"], fonction (e, t) {w.cssHooks [ t] = _ e (h.pixelPosition, fonction (e, n) {si (n) renvoie n = Fe (e, t), We.test (n)? w (e) .position () [t] + " px ": n})}), w.each ({Hauteur:" height ", Largeur:" width "}, fonction (e, t) {w.each ({padding:" inner "+ e, contenu: t , "": "outer" + e}, fonction (n, r) {w.fn [r] = fonction (i, o) {var a = arguments.length && (n || "booléen"! = typeof i) , s = n || (! 0 === i ||! 0 === o? "margin": "border"); retourne z (cette fonction (t, n, i) {var o; retourne y (t)? 0 === r.indexOf ("outer")? t ["inner" + e]: t.document.documentElement ["client" + e]: 9 === t.nodeType? (o = t.documentElement, Math.max (t.body ["scroll" + e], o ["scroll" + e], t. corps ["offset" + e], o ["offset" + e], o ["client" + e])): void 0 === i? w.css (t, n, s): w.style (t, n, i, s)}, t, a? i: void 0, a)}}}}), w.each ("flou focus focus focus focus focus redimensionner faire défiler cliquez sur dblclick mousedown mousemove mouseover mouseout mouseenter mouseleave changer submit keydown appuyer sur la touche keym contextmenu ".split (" "), fonction (e, t) {w.fn [t] = fonction (e, n) {renvoyer arguments.length> 0? this.on (t, null, e , n): this.trigger (t)}}), w.fn.extend ({survol: fonction (e, t) {retour this.mouseenter (e) .mouseleave (t || e)}}), w .fn.extend ({bind: function (e, t, n) {renvoie this.on (e, null, t, n)}, unbind: fonction (e, t) {renvoie this.off (e, null, t)}, délégué: fonction (e, t, n, r) {retourne this.on (t, e, n, r)}, non délégué:fonction (e, t, n) {retourne 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**",}}), w.proxy = fonction (e, t) {var n, r, i; si ("chaîne" == typede t && (n = e [t], t = e, e = n), g (e)) retourne r = o.call (arguments, 2), i = fonction () {retourne e.apply (t || ceci, r.concat (o.call (arguments)))}}, i.guid = e.guid = e .guid || w.guid ++, i}, w.holdReady = fonction (e) {e? w.readyWait ++: w.ready (! 0)}, w.isArray = Array.isArray, w.parseJSON = JSON.parse , w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, type.w = x, w.now = Date.now, w.isNumeric = fonction (e) {var t = w.type (e); return ("nombre" === t || "chaîne" === t) &&! isNaN (e-parseFloat (e))}, "fonction" == typede définir && define.amd && define ( "jquery", [], function () {return w}); var Jt = e.jQuery, Kt = e. $; return w.noConflict = function (t) {return e. $ === w && (e. $ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w}, t || (e.jQuery = e. $ = w), w});